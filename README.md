
# fasteR: Fast Lane to Learning R! 

![alt text](https://raw.githubusercontent.com/matloff/prVis/master/data/SwissRoll/SWwithY.png)

## *"Becoming productive in R, as fast as possible"*

### Norm Matloff, Prof. of Computer Science, UC Davis; [my bio](http://heather.cs.ucdavis.edu/matloff.html)
### 翻译：孙方，山东建筑大学商学院；（还在持续改进中）
(See notice at the end of this document regarding copyright.)

这个网站是为那些对R一无所知，甚至对编程一无所知的人而设的，他们寻求*快速、无痛!*踏入R世界。

* **快速**:  你将在你的第一堂课中就开始做一些有用的R数据分析。

* **面向非程序员**: 如果你熟悉浏览网页和查看图表，那就没问题了。这个教程是为你而设计的，而不是针对有经验的C或Python编程者。

* **激发兴趣**: 每一课都围绕着一个要解决的*真实问题*，基于*真实数据*。这些课程不是由一些与现实世界无关的玩具示例组成的。材料以一种对话式、叙事的方式呈现。

* **只是基础知识，没有花哨或争论**:

    - 值得注意的是，在最初的几堂课中，我们不使用集成开发环境（IDEs）。 RStudio、ESS等是很好的工具，但您不应该同时学习R和学习IDE，这会分散注意力，阻碍您尽快在R中变得高效的目标。请注意，即使是由[R-Ladies Sydney](https://threadreaderapp.com/thread/1119025557830684673.html)提供的优秀课程，也在使用RStudio，但对RStudio的评价是**过于庞大**

      因此，在最初的几堂课中，我们坚持使用R命令行，并专注于数据分析，而不是诸如IDE之类的工具，这将作为中级主题进行讲解。 （本教程的一些读者可能已经在使用RStudio或外部编辑器，这里的处理将在需要时为他们提供特别的说明。）

    - 覆盖范围主要限于基本的R。例如，自诩为“有主张”的Tidyverse并没有得到处理，部分原因是因为它具有争议性质（我是一个[Tidyverse怀疑者](http://github.com/matloff/TidyverseSkeptic)），但主要原因是它会阻碍你快速在R中变得高效。虽然你可以迅速学到一些简单的、"消毒过的"东西，认为你学到了很多，但这些东西的范围相当有限，Tidy学习者通常在将R应用于实际情况时会遇到困难。我们的教程是为那些目标是*在他们自己的数据分析中高效使用R系统*的学习者而设计的。
    - **专业提示部分：** 陷阱、便捷技巧、一般建议。




* **非被动学习方法:** 纯粹观看屏幕是无法学到东西的。编码不是一种"旁观者运动"；你必须以非被动的方式尝试这些概念。因此，会有偶尔出现**轮到你了**的部分，你作为学习者必须设计并尝试自己对所学内容的变体。有时教程会给你一些建议，但即使在这种情况下，你也应该想出自己的变体来尝试。 <span style="color:red">记住：你付出什么，就会得到什么！</span> 你在**轮到你了**部分积极参与的越多，你作为R编码者的能力就会越强大。


**需要覆盖多少内容？**

* 第一部分是基础知识，第二部分是高级主题。

* 如果您只打算覆盖第一部分，Lessons 1 到 11 应被视为最低限度。


## 目录

**第 I 部分**
* [第 1 课：入门](#overview)
* [第 2 课：首次使用R](#firstr)
* [第 3 课：向量和索引](#vecidxs)
* [第 4 课：更多关于向量](#less2)
* [第 5 课：进入数据框！](#less3)
* [第 6 课：R因子类](#less4)
* [第 7 课：从数据框提取行/列](#extractdf)
* [第 8 课：提取行、列的更多示例](#moreextract)
* [第 9 课：tapply函数](#tapply)
* [第 10 课：数据清理](#less5)
* [第 11 课：R列表类](#less6)
* [第 12 课：对尼罗河数据的另一种看法](#less7)
* [第 13 课：暂停反思](#pause1)
* [第 14 课：基础R图形简介](#less8)
* [第 15 课：更多关于基础图形](#less9)
* [第 16 课：编写自己的函数](#less10)
* [第 17 课：`For`循环](#less11)
* [第 18 课：带块的函数](#ftnbl)
* [第 19 课：文本编辑和IDE](#edt)
* [第 20 课：If、Else、Ifelse](#ifelse)
* [第 21 课：职业运动员保持健康吗？](#keepfit)
* [第 22 课：线性回归分析，I](#linreg1)
* [第 23 课：S3类](#s3)
* [第 24 课：棒球球员分析（续）](#less15)
* [第 25 课：R包、CRAN等](#cran)

**第 II 部分**
* [第 26 课：在继续深入研究之前的暂停](#advanced)
* [第 27 课：初探ggplot2](#gg2first)
* [第 28 课：应该使用函数式编程吗？](#appfam)
* [第 29 课：简单文本处理，I](#txt)
* [第 30 课：简单文本处理，II](#txt1)
* [第 31 课：线性回归分析，II](#linreg2)
* [第 32 课：使用R日期类](#dates)
* [第 33 课：有关R编码风格和策略的技巧](#style)
* [第 34 课：逻辑模型](#logit)
* [第 35 课：文件和目录](#fd)
* [第 36 课：R `while` 循环](#whl)
* [了解更多](#forMore)
* [感谢](#thanks)
* [附录：安装和使用RStudio](#rstudio)

## <a name="overview"> </a> 第一课：入门

目前，这个在线课程的主要部分将是这个**README.md**文件。尽管它设置成一个潜在的R包，但我可能会在以后实现这一点。

文件顶部的彩色图是由我们的[**prVis包**](https://github.com/matloff/prVis/)生成的，运行在一个名为*Swiss Roll*的著名数据集上。

### <a name="noteasy"> </a> 
> 📘 请再次注意，并始终记住：  
> 
> * 非被动学习绝对关键！所以，即使在这里显示了一个R命令的输出，也请在你的R控制台中自己运行该命令，通过从本文档复制粘贴到R控制台。再次强调，*你将从这个教程中得到什么，取决于你投入了什么。*
> 
> * 同样，**轮到你了**部分是非常关键的。设计你自己的小例子，然后尝试它们！"当有疑问时，试一试！"是我为教学设计的座右铭。如果你对某些事情感到不清楚或好奇，试一试！只需设计一个小实验，然后输入代码。别担心——你不会"弄坏"东西的。
> 
> * 我不能*教*你如何编程。我只能给你工具，比如R向量，以及一些例子。因此，对于给定的期望的编程任务，你必须创造性地将这些工具组合起来以达到目标。把它当作一个拼图！我认为你会发现，如果你坚持下去，你会发现自己在这方面相当擅长。毕竟，我们都能解决难题。
> 
> * 出于这样的原因，人们必须记住*并不总是有一种简单的方式来编写给定的任务*。随着你在这些课程中的进展，它们会变得越来越复杂。成为一个好的程序员的本质是耐心和坚持。然后你就能完成那些复杂的任务！


### 开始：

您需要[安装R](https://www.datacamp.com/community/tutorials/installing-R-windows-mac-ubuntu)，可以从[R项目站点](https://www.r-project.org)下载。启动R，可以通过点击图标或在终端窗口中键入 `R` 来进行。在这里我们不要求使用RStudio，但如果你已经有了，启动它；你将在R控制台中键入，也就是Console窗格。

正如上面提到的，这个教程将是"基础知识"。特别地，没有脚本来为您键入命令。相反，您将要么从这里的文本复制粘贴到R控制台中，要么手动在那里输入。 （请注意，这里的代码行都将以R交互提示符 `>` 开始；不应该输入它。）

这是一个Markdown文件。您可以在GitHub上直接阅读它，它有自己的Markdown渲染器。或者您可以在Chrome中将其下载到自己的计算机上，并使用Markdown Reader扩展查看它（请确保启用“允许访问文件URL”）。

当您结束R会话时，通过键入 `quit()` 退出。

祝你好运！如果有任何问题，请随时给我发送电子邮件，我的邮箱是matloff@cs.ucdavis.edu

## <a name="firstr"> </a> 第二课：R的第一步

R命令提示符是 `>`。同样，它将在这里显示，但您不需要键入它。它只是在您的R窗口中，让您知道R正在邀请您提交一个命令。（如果您使用的是RStudio，您将在Console窗格中看到它。）

所以，只需输入 `1+1` 然后按Enter。确实，它输出了2（你可能期望的是12108吗？）：

```r
> 1 + 1
[1] 2
```

但这里的 `[1]` 是什么呢？这只是一个行标签。我们稍后会讨论这个，目前还不需要。

### 示例：尼罗河数据

R包含许多内置数据集，主要用于说明目的。其中之一是**Nile**，涉及尼罗河100年的年度流量数据。

让我们找到平均流量：

```r
> mean(Nile)
[1] 919.35
```

这里的**mean**是R的*函数*的一个示例，而在这种情况下，Nile是该函数的一个*参数*，这是一个说法，表示"输入"。输出的919.35被称为*返回值*或简称*值*。运行函数的行为被称为*调用*函数。 （记住这些术语！）

另一个需要注意的地方是，我们不需要调用R的**print**函数；平均流量会自动打印出来。我们将很快看到这样做的原因，但我们也可以键入：

```r
> print(mean(Nile))
```

R（和其他语言中的）中的函数调用是"从内而外"的。在这里，我们要求R找到尼罗数据的平均值（我们的内部调用），然后打印结果（对**print**函数的外部调用）。

但是，无论何时我们在R的 `>` 提示符处，我们键入的任何表达式都会被打印出来，因此不需要调用**print**。

由于这里只有100个数据点，打印它们出来并不难。同样，我们只需键入`Nile`，无需调用**print**：



``` r
> Nile
Time Series:
Start = 1871 
End = 1970 
Frequency = 1 
  [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020
 [16]  960 1180  799  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840
 [31]  874  694  940  833  701  916  692 1020 1050  969  831  726  456  824  702
 [46] 1120 1100  832  764  821  768  845  864  862  698  845  744  796 1040  759
 [61]  781  865  845  944  984  897  822 1010  771  676  649  846  812  742  801
 [76] 1040  860  874  848  890  744  749  838 1050  918  986  797  923  975  815
 [91] 1020  906  901 1170  912  746  919  718  714  740
```

现在你可以看到行标签是如何工作的。每行有15个数字，所以第二行从第16个开始，用`[16]`表示。第三行从第31个输出数字开始，因此有`[31]`等等。因此，如果我们想找到，比如说，第78个值，我们看一下标记为[76]的第三行中的第三个数字，得到874。

请注意，像**Nile**这样的一组数字被称为*向量*。这个是一种特殊类型的向量，即*时间序列*，向量的每个元素记录了时间上的特定点，在这里由1871年到1970年的年份组成。因此，我们知道这个向量的长度是100个元素。但是一般来说，我们可以通过调用**length**函数来找到任何向量的长度，例如：

```r
> length(Nile)
[1] 100
```

 
如果您对函数的参数不确定，R提供了**args**函数。例如，我们稍后将使用**sort**函数，该函数将一组数字从最低到最高（或反之亦然）进行排序。

例如：

``` r
> sort(Nile)
  [1]  456  649  676  692  694  698  701  702  714  718  726  740  742  744  744
 [16]  746  749  759  764  768  771  774  781  796  797  799  801  812  813  815
 [31]  821  822  824  831  832  833  838  840  845  845  845  846  848  860  862
 [46]  864  865  874  874  890  897  901  906  912  916  918  919  923  935  940
 [61]  944  958  960  963  969  975  984  986  994  995 1010 1020 1020 1020 1030
 [76] 1040 1040 1050 1050 1100 1100 1100 1110 1120 1120 1140 1140 1150 1160 1160
 [91] 1160 1170 1180 1210 1210 1220 1230 1250 1260 1370
```

(Again, the return value from the call to **sort** was printed out
automatically.)

We can query **sort**'s arguments:

``` r
> args(sort)
function (x, decreasing = FALSE, ...) 
NULL
```

我们看到**sort**函数有名为**x**和**decreasing**的参数（实际上还有更多，但暂时放在一边）。

### 第一个图形

R具有出色的图形功能，不仅在基础R中，还在一些出色的用户贡献的包中，如**ggplot2**和**lattice**。但是我们现在将使用基础R图形，将更强大但更复杂的**ggplot2**留到以后的课程。

我们将从一个非常简单、没有花哨的直方图开始：

```r
> hist(Nile)
```

就像任何函数一样，**hist** 有一个返回值，但在这种情况下，我们没有保存它。返回值包含了箱子计数、箱子边界等信息。

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/Nile.png)

> ❄️  轮到你了
>
> 一组数字的*中值*是一个值x，使得一半的数字小于x，另一半大于x（有一些关于相同值的问题，但在这里不重要）。中值可能小于均值，也可能大于均值。确定**Nile**数据的中值属于这两种情况中的哪一种；R中的中值函数当然被命名为**median**。
>
> **hist**函数在直方图中默认为这个数据集绘制了10个柱，但您可以通过为函数指定一个可选的第二个参数**breaks**来选择其他值。例如：
> ```r
> > hist(Nile,breaks=20)
> ```
> 
> 将使用20个柱绘制直方图。尝试使用多个不同的大和小值绘制柱的数量。

**注意：**像**hist**函数这样的函数，就像许多R函数一样，有许多不同的选项，可以通过各种参数指定。现在，我们将保持简单，抵制探索它们的诱惑，但R有很多在线帮助，您可以通过 `?` 访问。例如，键入

```r
> ?hist
```

将告诉您有关**hist**函数的所有选项的完整信息。再次强调，现在对于您来说有太多了（大多数用户从未发现有必要使用更奇特的选项），但这是一个非常重要的资源，值得知道。

> 📘 专业提示
>
> 许多人喜欢通过添加括号来指定函数。例如，他们会写类似于“**length**函数经常很方便”的东西，而不是写“**length()**函数经常很方便”，以确保其他人知道他们正在谈论一个函数。我有时也这样做，但在某些情况下可能会导致麻烦。考虑以下例子：
>
> ```r
> > args(sort)
> function (x, decreasing = FALSE, ...) 
> NULL
> > args(sort())
> Error in sort.default() : argument "x" is missing, with no default
> ```
>
> 出了什么问题？在第一种情况下，我们询问**args**关于一个类型为'function'的对象**sort**的信息。在第二种情况下，我们实际上*调用了* **sort**。而后者函数本身期望一个参数，我们没有提供。 （而且也不合适。）
>
> 这里的问题相当明显——嗯，事后看来很多事情都是“明显”的，不是吗？——但它也可能发生得更加微妙。
> 
> 这说明了在编码中，我们必须非常小心地识别微妙的差异，在这种情况下是*函数*和对该函数的*调用*之间的差异。在普通英语中，我们可能会说，“那辆车想左转”而不是“那辆车的*司机*想左转”，但在编码中，我们必须非常挑剔。

> ❄️  轮到你了
>
> 编写代码将**Nile**数据从最大值到最小值进行排序，而不是相反。
> 默认情况下，调用 **hist()** 将显示该图表，但我们可以通过设置其参数来抑制显示。如果我们希望保存此函数的返回值，我们可能希望抑制显示。查看在线帮助以确定哪个参数可以实现这一点，并验证它是否有效，即它确实抑制了显示。
>
> 查找 **order** 函数（'?'），并在 **Nile** 数据上尝试它，并检查它是否按您的预期工作。


## 第三课：向量与索引

假设我们想要找到1950年后的河流平均流量。

上述输出表明**尼罗河**系列始于1871年。这意味着1951年将是第81年，而第100年将是1970年。我们如何指定数据中的第81到100个元素？

可以使用*下标*或*索引*（单数为*索引*）来访问单个元素，使用方括号指定，例如

``` r
> Nile[2]
[1] 1160
```

对于第二个元素（我们之前看到的输出确实显示第二个元素为1160）。这里的值2是索引。

**c**（"连接"）函数构建一个向量，将几个数字串在一起。例如，我们可以获取**尼罗河**的第2、第5和第6个元素：

``` r
> Nile[c(2,5,6)]
[1] 1160 1160 1160
```

如果我们希望构建一个包含*连续*数字的向量，可以使用“冒号”表示法：

``` r
> Nile[c(2,3,4)]
[1] 1160  963 1210
> Nile[2:4]
[1] 1160  963 1210
```

正如你看到的，2:4是指定向量c(2,3,4)的简洁方式。

因此，81:100表示从81到100的所有数字。因此**Nile[81:100]**指定了**Nile**向量中的第81到100个元素。

然后，为了回答关于1951-1971年平均流量的问题，我们可以执行以下操作：

``` r
> mean(Nile[81:100])
[1] 877.05
```

> **注意：**请注意上述推理过程的运作方式。我们有一个目标，即找到1950年后的平均河流流量。我们知道我们有一些可以使用的工具，即**mean**函数和R向量索引。然后，我们必须找出一种将这些工具结合在一起以实现我们目标的方法，我们成功做到了。

这就是R的一般工作方式。在浏览本教程时，您将为R的“工具箱”增加越来越多的内容。然后，对于任何给定的目标，您将在该工具箱中四处寻找，并最终找到适用于手头目标的正确工具集。有时这需要一些耐心，但您会发现，您所做的越多，您就变得越熟练。

如果我们计划在这段时间内进行更多操作，我们应该制作一个副本：

``` r
> n81100 <- Nile[81:100]
> mean(n81100)
[1] 877.05
> sd(n81100)
[1] 125.5583
```

函数**sd**找到标准偏差。

请注意，我们在这里使用了R的*赋值运算符*来将这些特定的**Nile**元素复制（“分配”）到**n81100**中。（在大多数情况下，您可以使用`=`而不是`<-`，但为什么要担心可能存在的例外情况呢？它们是深奥的，因此最好始终使用`<-`。虽然这里可以使用此操作的“键盘快捷键”，但我们现在还是坚持基础知识为好。）

还要注意，尽管我们将上述操作称为“提取”**Nile**的第81到100个元素，但我们实际上只是制作了这些元素的副本。原始向量**Nile**保持不变。

> 📘 专业提示
>
> 我们几乎可以选择任何想要的名称；“n81100”只是为了方便记住这个新向量的来源而选择的名称。（但名称不能包含空格，并且必须以字母开头。）

请注意，**n81100**现在是一个包含20个元素的向量。它的第一个元素现在是**Nile**的第81个元素：

``` r
> n81100[1]
[1] 744
> Nile[81]
[1] 744
```

请记住，尽管**Nile**和**n81100**现在具有相同的内容，它们是*独立*的向量；如果一个发生变化，另一个将不会发生变化。


请记住，另一个经常使用的函数是**length**，它给出向量的元素数，例如

``` r
> length(Nile)
[1] 100
```

你能猜到**length(n81100)**的值吗？在'>'提示处键入此表达式以检查您的答案。

> ❄️  轮到你了
>
> 编写代码来计算 1945 年至 1960 年尼罗河的平均高度。
>
> 尼罗河在哪个时期的平均高度更高，前 50 年还是后 50 年？

### 小结：在这前两课中我们学到了什么？

* 启动和退出R。

* 一些R函数：**mean**，**hist**，**length**。

* R向量和向量索引。

* 提取向量子集。

* 使用**c**和“:”函数形成向量。

对于第一课来说，这还不错！毫无疑问，您将在随后的课程和您对R的使用中频繁使用所有这些。

## 第四课：更多关于向量

沿着尼罗河继续，假设我们想知道有多少年的水位超过了120

0。让我们首先介绍R的**sum**函数：

``` r
> sum(c(5,12,13))
[1] 30
```

这里***c***函数构建了一个包含5、12和13的向量。然后，该向量被输入到**sum**函数中，返回5+12+13=30。

顺便说一下，上面是我们第一个*函数组合*的示例，其中一个函数的输出（在这里是***c***）被作为输入馈送到另一个函数中（在这种情况下是**sum**）。

现在我们可以使用这个来回答我们关于**Nile**数据的问题：

``` r
> sum(Nile > 1200)
[1] 7
```

河流水位在7年内超过了1200。

**但是这是如何运作的呢？**请耐心等待片刻。让我们首先看一个小例子：

``` r
> x <- c(5,12,13)
> x
[1]  5 12 13
> x > 8
[1] FALSE  TRUE  TRUE
> sum(x > 8)
[1] 2
```

首先，请注意这里的表达式**x > 8**中的一些奇怪之处。这里**x**是一个向量，长度为3，但8只是一个数字。询问一个向量是否大于一个数字似乎是没有意义的；它们是不同的动物。

但是R通过将该数字8扩展为一个3元素向量8,8,8，将它们变成“相同类型”的动物。这称为*循环*。这设置了逐个元素的比较：然后，**x**中的5与第一个8进行比较，产生FALSE，即5不大于8。然后，12与第二个8进行比较，产生TRUE，然后13与第三个8进行比较产生另一个TRUE。因此，我们得到了向量FALSE,TRUE,TRUE。

好了，但是**sum**如何将一些TRUE和FALSE相加呢？答案是R，像大多数计算机语言一样，将TRUE和FALSE视为1和0，分别处理。因此，我们对向量（0,1,1）求和，得到2。

回到关于尼罗河流量超过1200年数的问题，让我们再次看看那个表达式：

``` r
> sum(Nile > 1200)
```

由于向量**Nile**的长度为100，那个数字1200将被循环成一个包含一百个1200的向量。然后'>'比较将产生100个TRUE和FALSE，因此求和会给我们TRUE的数量，正是我们想要的。

与*有多少*年流量超过1200有关的问题是哪些年具有该特性。实际上，R实际上有一个**which**函数：

``` r
> which(Nile > 1200)
[1]  4  8  9 22 24 25 26
```

因此，**Nile**中的第4、第8、第9等元素具有查询的特性。（请注意，这些是1875年，1879年等。）

实际上，这为我们提供了另一种获得具有该特性的年份计数的方法：

``` r
> which1200 <- which(Nile > 1200)
> which1200
[1]  4  8  9 22 24 25 26
> length(which1200)
[1] 7
```

当然，像往常一样，我选择的变量名“which1200”是任意的，只是帮助我记住该变量中存储了什么的东西。

R的**length**函数做了它说的事情，即找到向量的长度。在我们的情境中，这给我们提供了流量超过1200的年份计数。

那么，在这7年中，河流的流量是多少？

``` r
> which1200 <- which(Nile > 1200)
> Nile[which1200]
[1] 1210 1230 1370 1210 1250 1260 1220
```

最后，再来点复杂的。我们可以组合上面的步骤：

``` r
> Nile[Nile > 1200]
[1] 1210 1230 1370 1210 1250 1260 1220
```

我们刚刚“消除了中间人”**which1200**。R解释器看到我们的“Nile > 1200”，然后生成相应的TRUE和FALSE。然后，R解释器将这些TRUE和FALSE视为**Nile**中的下标，从而提取所需的数据。

现在，我们可能要在这里补充一句，“孩子们，别在家里尝试这个。”对于初学者来说，将事情分成步骤确实更容易、更舒适。一旦您在R上有经验，您可能希望开始跳过一些步骤。
> ❄️  轮到你了
>
> 假设我们对尼罗河高度低于 950 的年份感兴趣。编写代码来确定：(a) 有多少这样的年份，(b) 这些年份具体是哪些，以及 (c) 在这些年份中的中位高度。
>
> 尝试一些其他你自己选择的实验，使用 **sum**。我建议从计算 **Nile** 的前 25 个元素的总和开始。你可能希望从一个小向量开始实验，比如 (2,1,1,6,8,5)，这样你就能知道你的答案是否正确。记住，你会以非被动方式学得更好。开始编写代码吧！
> 
> 还有一个非常有用的概念是负索引，例如：
> 
> ``` r
> > x <- c(5,12,13,8)
> > x[-1]  
> [1] 12 13  8
> ```
> 
> 这里我们要求所有的 **x**，*除了* **x[1]**。你能猜到 **x[c(-1,-4)]** 会得出什么结果吗？先猜一下，然后试一试。
>

关于最后一点：

> 📘 专业提示
>
> 我教给学生的一个口号是：“有疑问就试一试！”养成制定一些小实验的习惯，可以检查你不确定的某些 R 方面的行为。


### 小结：在这节课中我们学到了什么？

在这里，你已经完善了你在R向量上的技能，学到了R的循环利用特性以及R用户用于查找数量的两个技巧。

当你在本教程中继续学习时，你会发现这些东西在R中经常被使用。

## <a name="less3"> </a> 第5课：进入数据框！

在向量之后，R的下一个主要工具是*数据框*。它是一个由每个数据点一行组成的矩形表格。

假设我们有100个人的身高、体重和年龄。我们的数据框将有100行和3列。例如，在第二行和第三列中的条目将是我们数据中第二个人的年龄。整个第二行将是该第二个人的所有数据，即该人的身高、体重和年龄。

**注意该行也被视为一个向量。第三列整体将是我们数据集中所有年龄的向量。**

作为我们第一个例子，考虑R内置的**ToothGrowth**数据集。同样，你可以通过键入以下命令来阅读它：

```r
> ?ToothGrowth
```

数据实际上是关于豚鼠的，使用橙汁或维生素C作为生长补充剂。让我们从命令行快速查看。

```r
> head(ToothGrowth)
   len supp dose
1  4.2   VC  0.5
2 11.5   VC  0.5
3  7.3   VC  0.5
4  5.8   VC  0.5
5  6.4   VC  0.5
6 10.0   VC  0.5
```

R的**head**函数（默认情况下）显示给定数据框的前6行。我们看到有长度、补充剂和剂量列，数据的管理员决定将它们命名为'len'、'supp'和'dose'。每一列都是一个R向量，或者在第二列的情况下，是一个称为*factor*的类似向量的对象，稍后将讨论）。  

> 📘 专业提示
>
> 为了避免反复写出长单词，使用较短的名称制作副本是很方便的。

```r
> tg <- ToothGrowth
```

美元符号用于表示各个列，例如**ToothGrowth$dose**表示剂量列。因此，例如，我们可以打印出牙齿长度的平均值：

```r
> mean(tg$len)
[1] 18.81333
```

数据框中的下标/索引是一对，指定行和列号。要获取第3行第1列的元素：

```r
> tg[3,1]
[1] 7.3
```
这与我们在**head**示例中看到的相符。或者，使用**tg$len**是一个向量的事实：

```r
> tg$len[3]
[1] 7.3
```

在*数据框* **tg** 中的第3行第1列的元素对应于 *向量* **tg$len** 中的第3个元素。R经常在数据框和向量之间的这种二元性上进行操作。

> ❄️  你的回合
>
> 上面的例子对于R来说是基础的，因此这次你应该自己进行一些小实验，稍微变换一下上面的例子。你做得越多，就越好！

对于数据框**d**的任何子集，我们都可以使用以下格式提取我们想要的行和列：

```r
d[我们想要的行，我们想要的列]
```

有些数据框没有列名，但这不是问题。我们可以使用列号，例如：

```r
> mean(tg[,1])
[1] 18.81333
```

注意表达式'[,1]'。由于第二个位置上有个1，我们正在谈论第1列。由于逗号前的第一个位置是空的，没有指定行，因此*所有*行都包括在内。这归结为：所有的第1列。

R的一个关键特性是可以提取数据框的子集，就像我们之前提取向量的子集一样。例如，

```r
> z <- tg[2:5,c(1,3)]
> z
   len dose
2 11.5  0.5
3  7.3  0.5
4  5.8  0.5
5  6.4  0.5
```

在这里，我们提取了第2到第5行和第1到第3列，将结果赋给了**z**。要提取这些列但保留所有行，可以执行：

```r
> y <- tg[ ,c(1,3)]
```

即留下行规范字段为空。

顺便说一下，注意这三列的长度都是相同的，这是数据框的要求。在这种情况下，这个共同的长度是多少？R的**nrow**函数告诉我们任何数据框中的行数：

```r
> nrow(ToothGrowth)
[1] 60
```

啊，60行（60只

豚鼠，每只测量3次）。

或者，也可以这样：

```r
> tg <- ToothGrowth
> length(tg$len)
[1] 60
> length(tg$supp)
[1] 60
> length(tg$dose)
[1] 60
```

所以现在你知道四种做同样事情的方法。但一个不够吗？当然。但在这个熟悉阶段，阅读所有四种方法将有助于强化你现在对R知识的累积。所以，请确保你理解这四种方法是如何产生数字60的。

**head**函数也适用于向量：

```r
>  head(ToothGrowth$len)
[1]  4.2 11.5  7.3  5.8  6.4 10.0
```

像许多R函数一样，**head**有一个可选的第二个参数，指定要打印多少元素：

```r
> head(ToothGrowth$len,10)
 [1]  4.2 11.5  7.3  5.8  6.4 10.0 11.2 11.2  5.2  7.0
```

你可以创建自己的数据框——这对于测试你的理解非常有用——方法如下：

```r
> x <- c(5,12,13)
> y <- c('abc','de','z')
> d <- data.frame(x,y)
> d
   x   y
1  5 abc
2 12  de
3 13   z
```

看看第二行！可以形成由字符字符串组成的向量，具有完整的索引功能，例如

```r
> y <- c('abc','de','z')
> y[2]
[1] "de"
```

正如前面提到的，数据框中的所有列必须具有相同的长度。在这里**x**由3个数字组成，而**y**由3个字符字符串组成。（后者的单位是字符串。每个字符串中的字符数是无关紧要的。）

对于行和列，也可以使用负索引，例如

```r
> z <- tg[,-2]
> head(z)
   len dose
1  4.2  0.5
2 11.5  0.5
3  7.3  0.5
4  5.8  0.5
5  6.4  0.5
6 10.0  0.5
```

> ❄️  你的回合
>
> 想出一些关于**ToothGrowth**数据的小例子。例如，编写代码查找牙齿长度小于16的情况数量，以及VC补充剂所在的行是哪些。 
>
> 此外，尝试使用另一个内置的R数据集**faithful**进行一些示例。这个数据集涉及美国黄石国家公园的老忠实间歇泉。第一列给出了喷发的持续时间，第二列是距上次喷发的等待时间。正如前面提到的，这些操作是R的关键特性，因此尽可能设计并运行尽可能多的示例；最好是偏向做得多一些！

### 小结：在这节课中我们学到了什么？

如前所述，数据框是R的基本工具。它由向量（长度相等）的列组成，这一事实经常很方便。

与向量的单一数字索引不同，数据框中的每个元素都有两个索引，一个是行号，一个是列号。我们可以指定要提取的行和列的集合以提取子框。

可以使用R的**nrow**函数查询数据框中的行数；**ncol**对于列数也是如此。

## <a name="less4"> </a> 第 6 课：R因子类

在R中，每个对象都有一个*类*。数字3的类是**'numeric'**，字符字符串'abc'的类是**'character'**等等。 （在R中，类名需要引号；可以使用单引号或双引号。）请注意，数字向量也是**'numeric'**类；实际上，单个数字被认为是长度为1的向量。因此，例如**c('abc','xw')**也是**'character'**。

> 📘 专业提示
>
> 计算机要求人非常小心，非常精确。在上面的**c('abc','xw')**表达式中，人们可能会想知道为什么它没有评估为'abcxw'。毕竟，我不是说过'c'代表"连接"吗？是的，但是**c**函数连接*向量*。这里'abc'是长度为1的向量——我们有*一个*字符字符串，它由3个字符组成是无关紧要的——同样，'xw'也是一个字符字符串。因此，我们正在连接一个包含1个元素的向量与另一个包含1个元素的向量，结果是一个包含2个元素的向量。

那么在上面的维生素C的例子中**tg**和**tg$supp**的类是什么？

```r
> class(tg)
[1] "data.frame"
> class(tg$supp)
[1] "factor"
```

当我们有*分类*变量时，R因子就会派上用场。例如，在一项基因研究中，我们可能有一个关于头发颜色的变量，它可能包括四个类别：黑色、棕色、红色、金色。我们可以通过以下方式找到**tg$supp**的类别列表：

```r
> levels(tg$supp)
[1] "OJ" "VC"
```

这里的分类变量是**supp**，这是数据集创建者为补充列选择的名称。我们看到有两个类别（*levels*），即橙汁或维生素C。

请注意，R因子的值必须用引号括起来。可以使用单引号或双引号都可以（尽管在使用**head**时不显示引号）。

> 📘 专业提示
>
> R的**factor**类是R中最强大的方面之一。在接下来的课程中，我们将逐渐掌握这项技能。确保真正熟练掌握它。

> ❄️  轮到你了
>
> 如前所述，R 包含许多内置数据集，你可以通过调用 **data()** 获取它们的列表。其中之一是 **CO2**。使用上面提到的 **class()** 函数，确定该数据集中的哪些列（如果有的话）属于 **factor** 类。



## <a name="extractdf"> </a> 第 7 课：从数据框中提取行/列

（读者应该特别慢慢而仔细地阅读这一课程。概念很简单，但将它们组合起来需要仔细检查。）

首先，让我们回顾一下前面一课中看到的内容：

```r
> which1200 <- which(Nile > 1200)
> Nile[which1200]
[1] 1210 1230 1370 1210 1250 1260 1220
```

在这里，我们学习了如何提取*向量元素*。我们可以类似地提取*数据框的行或列*。以下是方法：

继续使用维生素C的例子，让我们比较两种补充剂类型的平均牙齿长度。以下是代码：

```r
> whichOJ <- which(tg$supp == 'OJ')
> whichVC <- which(tg$supp == 'VC')
> mean(tg[whichOJ,1])
[1] 20.66333
> mean(tg[whichVC,1])
[1] 16.96333
```

在上述的前两行中，我们找到了**tg**（或等效地，**tg$supp**）中具有OJ补充剂的行，将这些行号记录在**whichOJ**中。然后我们对VC做了同样的事情。

现在，看一下表达式**tg[whichOJ,1]**。记住，数据框是用两个下标表达式访问的，一个是用于行，一个是用于列，格式如下：

```r
d[the rows we want, the columns we want]
```

因此，**tg[whichOJ,1]** 表示只关注OJ行，而且只有第1列，即牙齿长度。然后我们找到这些受限制的数字的平均值。结果是20.66333。然后对VC进行同样的操作。

同样，如果我们经验丰富，我们可以跳过一些步骤：

```r
> tgoj <- tg[tg$supp == 'OJ',]
> tgvc <- tg[tg$supp == 'VC',]
> mean(tgoj$len)
[1] 20.66333
> mean(tgvc$len)
[1] 16.96333
```

无论哪种方式，我们都得到了我们最初问题的答案：橙汁似乎比维生素C产生更多的生长。 （当然，可以为差异等形成置信区间。）

### 小结：在这节课中我们学到了什么？

正如我们之前学习如何使用TRUE和FALSE值序列提取向量的部分一样，我们现在看到了如何对数据框进行类似的操作：**我们可以使用TRUE和FALSE值序列从数据框

中提取某些行或列。**

在继续之前，读者必须充分理解这一课程，在自己进行一些上述示例的变化之前。我们将在本教程中经常使用这项技术，它对于在实际世界中使用R是至关重要的。

> ❄️  轮到你了
>
> 在 R 的内置 **faithful** 数据集上尝试一些操作。例如，提取所有等待时间超过 80 分钟的行组成的子数据框。

## <a name="moreextract"> </a> 第 8 课：更多提取行和列的例子

通常我们需要从数据框中提取行或列，满足多个条件。

例如，假设我们希望从 **tg** 中提取子数据框，其中 OJ 是处理组，并且长度小于 8.8。我们可以使用与符号'&'，它表示逻辑AND操作：

```r
> tg[tg$supp=='OJ' & tg$len < 8.8,]
   len supp dose
37 8.2   OJ  0.5
```

啊，结果表明只有一个案例同时满足两个条件。

如果我们想要满足至少一个条件的所有行，而不一定是两者，那么我们使用OR运算符'|'。例如，我们想要获取所有长度大于28或治疗剂剂量为1.0或两者的行：

```r
> tg[tg$len > 28 | tg$dose == 1.0,]
    len supp dose
11 16.5   VC    1
12 16.5   VC    1
13 15.2   VC    1
14 17.3   VC    1
15 22.5   VC    1
16 17.3   VC    1
17 13.6   VC    1
18 14.5   VC    1
19 18.8   VC    1
20 15.5   VC    1
23 33.9   VC    2
26 32.5   VC    2
30 29.5   VC    2
41 19.7   OJ    1
42 23.3   OJ    1
43 23.6   OJ    1
44 26.4   OJ    1
45 20.0   OJ    1
46 25.2   OJ    1
47 25.8   OJ    1
48 21.2   OJ    1
49 14.5   OJ    1
50 27.3   OJ    1
56 30.9   OJ    2
59 29.4   OJ    2
```

顺便说一下，原始的行号也被显示了。例如，满足条件的第一个案例在原始数据框**tg**中是第11行。

通常，我们不仅想提取数据框的一部分，还想保存结果：

```r
> w <- tg[tg$len > 28 | tg$dose == 1.0,]
```

再次强调，我随意选择了名字'w'。名称必须以字母开头，并且只能由字母，数字和一些特殊字符（例如'-'或'_'）组成。

请注意，**w**是一个新的数据框，我们可以对其执行通常的操作，例如

```r
> head(w)
    len supp dose
11 16.5   VC    1
12 16.5   VC    1
13 15.2   VC    1
14 17.3   VC    1
15 22.5   VC    1
16 17.3   VC    1
> nrow(w)
[1] 25
```

我们可能只对例如满足给定条件的*数量*感兴趣。与之前一样，我们可以使用**nrow**来实现，如下所示。

正如前面所看到的，我们还可以提取列。例如，我们的分析将仅使用牙齿长度和剂量。我们在“要提取的列是什么”位置写入'c(1,3)'，表示列1和3：

```r
> lendose <- tg[,c(1,3)]
> head(lendose)
   len dose
1  4.2  0.5
2 11.5  0.5
3  7.3  0.5
4  5.8  0.5
5  6.4  0.5
6 10.0  0.5
```

从现在开始，我们将使用**lendose**而不是**tg**。

不过，使用列名而不是数字指定列会更好一些：

```r
> lendose <- tg[,c('len','dose')]
> head(lendose)
   len dose
1  4.2  0.5
2 11.5  0.5
3  7.3  0.5
4  5.8  0.5
5  6.4  0.5
6 10.0  0.5
```

逻辑操作也适用于向量。例如，在**Nile**数据中，假设我们想知道有多少年的流量在极端值以下，例如低于800或高于1300：

```r
> exts <- Nile[Nile < 800 | Nile > 1300]
> head(exts)
[1] 1370  799  774  694  701  692
> length(exts)
[1] 27
```

顺便说一下，如果这个计数是我们唯一关心的，即我们对**exts**没有进一步的用途，我们可以跳过对**exts**的分配，直接进行操作：

```r
> length(Nile[Nile < 800 | Nile > 1300])
[1] 27
```

这对于经验丰富的R用户来说是可以的，但实际上，“一步一步”对于初学者来说更好。它更清晰，最重要的是，如果发生错误，调试起来更容易。

在 **Nile** 数据中，假设我们对一年到下一年的河流高度变化感兴趣。回想一下前几个元素：

``` r
> head(Nile)
[1] 1120 1160  963 1210 1160 1160
```

所以变化是 +40，然后是 -197 等等。我们如何编写一个包含所有变化的向量？

``` r
> nile1 <- Nile[-1]
> head(nile1)
[1] 1160  963 1210 1160 1160  813
> z <- nile1 - Nile
Warning message:
In `-.default`(nile1, Nile) :
  longer object length is not a multiple of shorter object length
> head(z)
[1]   40 -197  247  -50    0 -347
```

暂时忽略警告。这里发生了什么？

1. 删除 **Nile** 的第一个元素会将所有元素向左移动一个位置；即 **nile[1]** 是 **Nile[2]**，**nile[2]** 是 **Nile[3]**，依此类推。

2. 减法 **nile1 - Nile** 是逐个元素进行的，因此它产生了 **nile1[1] - Nile[1]**，**nile1[2] - Nile[2]** 等等。但这些是原始 **Nile** 数据中年度之间的差异，所以 **z** 现在正好包含我们想要的内容！

3. 但是，那个减法不太对。正如警告所告诉我们的那样，我们从长度为 99 的向量中减去了长度为 100 的向量。R 使用循环来将后者扩展到长度 100，但 **z** 的第 100 个元素是没有意义的。我们应该最后运行

   ``` r
   z <- z[-100]
   ```

在提取各种向量元素、行或列时，我们不必使用相同的顺序，例如：

``` r
> x <- c(5,12,13,8,168)
> 
> x
[1]   5  12  13   8 168
> w <- x[c(5,4)]
> w
[1] 168   8
> x[c(4,5)] <- w
> x
[1]   5  12  13 168   8
```

我们提取了 **x** 的第五个和第四个元素，按照这个顺序。然后我们将结果分配给 **w**，并且（无论我们是否有某种目的或只是为了好玩），我们将颠倒的数字重新分配到 **x** 中。

提取的实体也不需要连续，例如：

``` r
> x[c(1,4)]
[1]   5 168
```

### 小结：在本课中我们学到了什么？

在这里，我们有更多的练习操作数据框，并介绍了逻辑运算符'&'和'|'的另一个示例。我们还看到了使用**nrow**作为计算满足给定条件的行数的一种方法的另一个示例。

这些都是实际世界中R使用中经常遇到的“基本”操作。

顺便说一下，要注意R的本质是“将小事物组合起来以完成大事物”，例如将子集操作、'&'运算符和**nrow**结合起来以获取满足给定条件的行数。这也是R的“基本”之一。由你作为R用户创造性地组合R的小操作（以后还有一些大操作）以实现你对数据的任何目标的能力。*编程是一个创造性的过程*。就像杂货店和烹饪一样：商店有很多不同的潜在配料，你决定购买哪些并将它们组合成一顿饭。

> ❄️  轮到你了
>
> 在 R 的内置 **faithful** 数据集上尝试一些操作。
>
> 1. 找到 **faithful** 数据集中满足以下条件的行数：**eruptions** 列大于 3，等待时间超过 80 分钟。
>
> 2. 添加代码以打印出这些情况的行号。


## <a name="tapply"> </a> 第9课：`tapply` 函数

> 📘 专业提示
> 
> 在 R 中，通常有一种更短、更紧凑的方法来完成任务。在这里也是如此；我们可以在上面的示例中使用神奇的 **tapply** 函数。实际上，我们可以用一行代码完成。

调用 **tapply** 的一般形式是

``` r
tapply(要拆分的内容, 用于拆分的标准, 对结果组数据应用的操作)
```

``` r
> tapply(tg$len,tg$supp,mean)
      OJ       VC 
20.66333 16.96333 
```

简单来说："根据 **tg$supp** 的值将向量 **tg$len** 分成两组，然后对每组应用 **mean**。" 请注意，结果以向量形式返回，我们可以将其保存在，例如 **z** 中：

``` r
> z <- tapply(tg$len,tg$supp,mean)
> z[1]
      OJ 
20.66333 
> z[2]
      VC 
16.96333 
```

顺便提一下，**z** 不仅是一个向量，而且是一个 *命名* 向量，这意味着它的元素有名称，本例中是 'OJ' 和 'VC'。

保存可以非常方便，因为我们可以在后续代码中使用该结果。

为了确保清楚地理解这是如何工作的，让我们看一个小的人造例子：

``` r
> x <- c(8,5,12,13)
> g <- c('M',"F",'M','M')
```

假设 **x** 是一些孩子的年龄，他们是男孩、女孩，然后是两个男孩，如 **g** 所示。例如，5 岁的是一个女孩。

让我们调用 **tapply**：

``` r
> tapply(x,g,mean)
 F  M 
 5 11 
``` 

这个调用的意思是："根据 **g** 的相应元素将 **x** 分成两堆，然后在每堆中找到平均值。

请注意，**x** 和 **g** 上面的元素数量都是相同的，都是 4 个。如果相反，**g** 有 5 个元素，那么第五个元素将是无用的 —— 不存在的第五个孩子年龄在 **x** 中。类似地，如果 **g** 只有 3 个元素，那么第四个孩子就没有指定性别。

> 📘 专业提示
>
> 如果 **g** 的长度不对，我们会收到一个错误消息，“Arguments must be of the same length.” 这是 R 代码中常见的错误，所以要注意，要记住为什么长度必须相同。

除了 **mean**，我们可以在 **tapply** 中的第三个参数中使用任何函数。下面是另一个例子，使用内置数据集 **PlantGrowth**：

``` r
> tapply(PlantGrowth$weight,PlantGrowth$group,length)
ctrl trt1 trt2 
  10   10   10 
```

在这里，**tapply** 将 **weight** 向量根据 **group** 变量分成子集，然后在每个子集上调用 **length** 函数。我们看到每个子集的长度都是 10，即实验为对照组分配了 10 株植物，对治疗组 1 分配了 10 株植物，对治疗组 2 分配了 10 株植物。

> ❄️  轮到你了
>
> R 中最著名的内置数据集之一是 **mtcars**，其中包含了 60 年代和 70 年代的各种汽车测量数据。在这里，你有很多机会做一些小实验！
>
> 你可以从比较 4、6 和 8 气缸汽车的平均每加仑英里值开始。另一个建议是使用 **table** 找出每个气缸类别中有多少辆汽车。像往常一样，你在这里做的实验越多，就越好！

顺便说一句，**mtcars** 数据框有一列“幻影”列。

``` r
> head(mtcars)
                   mpg cyl disp  hp drat    wt  qsec vs am gear carb
Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
```

第一列似乎给出了汽车的品牌和型号。是的，确实是如此 —— 但它不是一列。看：

``` r
> head(mtcars[,1])
[1] 21.0 21.0 22.8 21.4 18.7 18.1
```

确实，第一列是 mpg 数据，而不是汽车名称。但我们在最左边看到了名称！这个看似矛盾的解决方法是，这些汽车名称是这个数据框的 *行名*：

``` r
> row.names(mtcars)
 [1] "Mazda RX4"           "Mazda RX4 Wag"       "Datsun 710"         
 [4] "Hornet 4 Drive"      "Hornet Sportabout"   "Valiant"            
 [7] "Duster 360"          "Merc 240D"           "Merc 230"           
[10] "Merc 280"            "Merc 280C"           "Merc 450SE"         
[13] "Merc 450SL"          "Merc 450SLC"         "Cadillac Fleetwood" 
[16] "Lincoln Continental" "Chrysler Imperial"   "Fiat 128"           
[19] "Honda Civic"         "Toyota Corolla"      "Toyota Corona"      
[22] "Dodge Challenger"    "AMC Javelin"         "Camaro Z28"         
[25] "Pontiac Firebird"    "Fiat X1-9"           "Porsche 914-2"      
[28] "Lotus Europa"        "Ford Pantera L"      "Ferrari Dino"       
[31] "Maserati Bora"       "Volvo 142E"         
```

所以 'Mazda RX4' 是第 1 行的 *名称*，但不是行的一部分。

和其他所有东西一样，**row.names** 是一个函数，正如你上面所看到的，它的返回值是一个 32 元素的向量（数据框有 32 行，因此有 32 个行名）。该向量的元素属于 **'character'** 类，向量本身也是如此。

你甚至可以对该向量进行赋值：

``` r
> row.names(mtcars)[7]
[1] "Duster 360"
> row.names(mtcars)[7] <- 'Dustpan'
> row.names(mtcars)[7]
[1] "Dustpan"
```

顺便说一下，这是一个内部笑话。是的，这个例子是真实且重要的，但 "Dustpan" 来自当时一个有趣的电视广告。

（如果你有一些编程背景，可能会觉得在赋值的 *左* 边调用一个函数有些奇怪。在 R 中这是很常见的。这源于 '<-' 实际上是一个函数！但这不是讨论这个问题的地方。）

> 📘 专业提示
>
> 作为一个初学者（事实上以后也一样），你不应该过于迷恋总是以 "最佳" 方式编写代码，包括代码的紧凑性。编写能够工作且清晰的代码更为重要；可以随时进行调整。不过，在这种情况下，**tapply** 实际上有助于清晰度，并且它是如此普遍有用，我们已经在本教程的早期引入了它。我们将在后面的课程中使用它更多。

## <a name="less5"> </a> 第10课：数据清理

大多数现实世界的数据都是“脏的”，即充满了错误。例如，著名的[纽约出租车行程数据集](https://data.cityofnewyork.us/Transportation/2017-Yellow-Taxi-Trip-Data/biws-g3hs)中有一次行程的目的地的纬度和经度将其放在了南极洲！这类错误数据对统计分析的影响可能从轻微到致命。让我们看看如何找出不良数据。在此过程中，我们将涵盖一些新的R概念。

我们将使用著名的Pima糖尿病数据集。有各种版本，但我们将使用**faraway**中包含的版本，这是由Julian Faraway编写的R软件包，他是关于R中统计回归分析的几本流行书籍的作者。

我已经将数据文件**Pima.csv**放在[我的网站](http://heather.cs.ucdavis.edu/FasteR/data/Pima.csv)上。以下是如何在R中读取它的方法：

```r
> pima <- read.csv('http://heather.cs.ucdavis.edu/FasteR/data/Pima.csv', header=TRUE)
```

数据集位于一个CSV（逗号分隔值）文件中。在这里，我们读取它，并将结果的数据框分配给我们选择命名为**pima**的变量。

注意第二个参数，**header=TRUE**。文件中的标题（如果存在）在文件的第一行中。它说明数据框中的列应该有什么名字。如果文件没有标题，则将**header**设置为FALSE。您随时可以稍后将名称添加到数据框中（在将来的课程中）。

> 📘 专业提示
>
> 查看新加载或构建的数据框总是一个好习惯：

```r
> head(pima)
  pregnant glucose diastolic triceps insulin  bmi diabetes age test
1        6     148        72      35       0 33.6    0.627  50    1
2        1      85        66      29       0 26.6    0.351  31    0
3        8     183        64       0       0 23.3    0.672  32    1
4        1      89        66      23      94 28.1    0.167  21    0
5        0     137        40      35     168 43.1    2.288  33    1
6        5     116        74       0       0 25.6    0.201  30    0
> dim(pima)
[1] 768   9
```

**dim**函数告诉我们在这项研究中有768人，每个人测量了9个变量，即数据有768行和9列。

由于这是一项糖尿病研究，让我们看一下葡萄糖变量。R的**table**函数非常方便。

```r
> table(pima$glucose)

  0  44  56  57  61  62  65  67  68  71  72  73  74  75  76  77  78  79  80  81 
  5   1   1   2   1   1   1   1   3   4   1   3   4   2   2   2   4   3   6   6 
 82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 
  3   6  10   7   3   7   9   6  11   9   9   7   7  13   8   9   3  17  17   9 
102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 
 13   9   6  13  14  11  13  12   6  14  13   5  11  10   7  11   6  11  11   6 
122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 
 12   9  11  14   9   5  11  14   7   5   5   5   6   4   8   8   5   8   5   5 
142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 
  5   6   7   5   9   7   4   1   3   6   4   2   6   5   3   2   8   2   1   3 
162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 
  6   3   3   4   3   3   4   1   2   3   1   6   2   2   2   1   1   5   5   5 
182 183 184 186 187 188 189 190 191 193 194 195 196 197 198 199 
  1   3   3   1   

 4   2   4   1   1   2   3   2   3   4   1   1 
```

在这里要小心; 第一、三、五等行是葡萄糖的值，而第二、四、六等行是具有这些值的女性的计数。例如，有3名女性的葡萄糖为68。

哎呀！在研究中，有5名女性的葡萄糖水平为0。还有1名水平为44，等等。可能0在生理上是不可能的，也许44也是不可能的。

让我们考虑一个葡萄糖数据的版本，至少排除了这些0。

```r
> pg <- pima$glucose
> pg1 <- pg[pg > 0]
> length(pg1)
[1] 763
```

与以前一样，表达式**pg > 0**创建了一个包含TRUE和FALSE的向量。过滤**pg[pg > 0]**将仅捕获TRUE的情况，确实，我们看到**pg1**仅有763个案例，而不是最初的768个; 葡萄糖为0的5个已经消失了。

删除0是否有很大的影响？结果证明并没有：

```r
> mean(pg)
[1] 120.8945
> mean(pg1)
[1] 121.6868
```

但是，实际上，这些事情确实可能对许多统计分析产生重大影响。

R具有用于缺失值的特殊代码，NA，用于这种情况。与其删除0，不如将它们重新编码为NA。让我们在原始数据集中执行此操作，以便将所有数据保留在一个对象中：

```r
> pima$glucose[pima$glucose == 0] <- NA
```

这有点复杂。以下是相同的操作，但分解为更小的步骤：

```r
> glc <- pima$glucose
> z <- glc == 0
> glc[z] <- NA
> pima$glucose <- glc
```

这是代码的工作原理：

- 第一行只是复制原始向量，以避免代码中的混乱。
- 第二行确定**glc**的哪些元素为0，导致**z**成为TRUE和FALSE的向量。
- 第三行然后将**glc**中对应于TRUE的元素分配为NA。（请注意NA的循环使用。）
- 最后，我们需要在原始数据中进行更改，因此我们将**glc**复制到它。

> 📘 专业提示
>
> 我们将原始1行代码拆分成了4行更简单的代码。
> 这样更清晰，而且顺便说一句，更容易调试。
> 我特别建议初学者使用这种方法，但对于所有人，我在自己的代码中经常使用这种方法。
>
> 有一个高级的R概念，*管道*，它也将较长的计算拆分为较小的步骤。我不使用管道（无论是Tidyverse版本还是较新的基本R管道），因为我认为它们不够清晰，而且非常重要的是，很难调试。您可能会发现您喜欢它们，这当然是可以的，但我们将在这里不使用它们。

> 📘 专业提示
>
> 再次注意上述代码中的双等号！如果我们想测试，例如，***a***和***b***是否相等，表达式必须是"a == b"，而不是"a = b"；后者会执行"a <- b"。这是一个著名的初学者错误。

作为检查，让我们验证葡萄糖变量现在有5个NA：

```r
> sum(is.na(pima$glucose))
[1] 5
```

这里内置的R函数**is.na**将返回一个TRUE和FALSE的向量。请记住，这些值始终可以视为1和0，因此可相加。因此，我们得到了我们的计数，为5。

让我们还验证均值是否正确：

```r
> mean(pima$glucose)
[1] NA
```

出了什么问题？默认情况下，**mean**函数将*不*跳过NA值；因此，均值也报告为NA。但是我们可以指示该函数跳过NA：

```r
> mean(pima$glucose, na.rm=TRUE)
[1] 121.6868
```

> ❄️  轮到你了
>
> 确定**pima**中还有哪些列存在可疑的0，并用NA值替换它们。
> 
> 现在，再次查看我们之前绘制的尼罗河流量直方图。低端的数字似乎存在间隙，并且其余的数字。这些对应于哪些年份？找出数据的均值，不包括这些情况。

## <a name="less6"> </a> 第11课：R列表类

我们之前已经看到了 **tapply** 函数的方便之处。让我们再来看一个相关的函数 **split**。后者的一般调用形式是

``` r
split(要分割的对象, 用于分割的条件) 
```

这看起来类似于我们之前看到的 **tapply** 的形式，

``` r
tapply(要分割的对象, 用于分割的条件, 
   对结果进行操作的方法)
```

但这并不奇怪，因为 **tapply** 的内部代码实际上调用了 **split**。（您可以通过 **edit(tapply)** 来检查这一点。）

之前我们提到了内置数据集 **mtcars**，一个数据框。考虑 **mtcars$mpg**，包含每加仑英里数的列。同样，为了节省输入并避免在代码中混乱，让我们先复制一份：

``` r
> mtmpg <- mtcars$mpg
```

假设我们希望将原始向量分割成三个向量，一个用于4缸汽车，一个用于6缸汽车，一个用于8缸汽车。我们*可以*这样做：

``` r
> mt4 <- mtmpg[mtcars$cyl == 4]
```

然后依此类推，得到 **mt6** 和 **mt8**。

> ❄️  轮到你了
>
> 为了跟上进度，请确保理解那行代码是如何工作的，其中包含 TRUE 和 FALSE 等。首先打印出 **mtcars$cyl == 4** 的值，然后继续。


但是有一种更清晰的方法：

``` r
> mtl <- split(mtmpg,mtcars$cyl)
> mtl
$`4`
 [1] 22.8 24.4 22.8 32.4 30.4 33.9 21.5 27.3 26.0 30.4 21.4

$`6`
[1] 21.0 21.0 21.4 18.1 19.2 17.8 19.7

$`8`
 [1] 18.7 14.3 16.4 17.3 15.2 10.4 10.4 14.7 15.5 15.2 13.3 19.2 15.8 15.0
> class(mtl)
[1] "list"
```
 **split** 的作用是：“将 **mtmpg** 分割成多个向量，分割准则是 **mtcars$cyl** 中对应的值。” 

现在 **mtl** 是一个R类为 **"list"** 的对象，包含了3个向量。我们可以使用美元符号符号来单独访问它们：

``` r
> mtl$`4`
 [1] 22.8 24.4 22.8 32.4 30.4 33.9 21.5 27.3 26.0 30.4 21.4
```

或者，我们可以使用索引，但现在要用双括号：

``` r
> mtl[[1]]
 [1] 22.8 24.4 22.8 32.4 30.4 33.9 21.5 27.3 26.0 30.4 21.4
```

``` r
> mtl[[2]][1:3]
[1] 21.0 21.0 21.4
```

再仔细看一下：

``` r
> head(mtcars$cyl)
[1] 6 6 4 6 8 6 
``` 

我们看到第一辆车有6缸，因此 **mtmpg** 的第一个元素21.0 被放入了 `6` 这一组中，即 **mtl[[2]]**（请参见上面的 **mtl** 打印输出），以此类推。

当然，我们也可以为以后方便做副本：

``` r
> m4 <- mtl[[1]]
> m6 <- mtl[[2]]
> m8 <- mtl[[3]]
```

列表特别适合在一个包中混合各种类型：

``` r
> l <- list(a = c(2,5), b = 'sky')
> l
$a
[1] 2 5

$b
[1] "sky"
```

注意，这里我们可以给列表元素命名为 'a' 和 'b'。在使用上面的 **split** 形成 **mtl** 时，名称是根据被分割的向量的值分配的。（在之前的情况中，我们还需要使用反引号 `` ` ``，因为名称是数字。）

如果我们不喜欢这些默认名称，我们可以更改它们：

``` r
> names(mtl) <- c('four','six','eight')
> mtl
$four
 [1] 22.8 24.4 22.8 32.4 30.4 33.9 21.5 27.3 26.0 30.4 21.4

$six
[1] 21.0 21.0 21.4 18.1 19.2 17.8 19.7

$eight
 [1] 18.7 14.3 16.4 17.3 15.2 10.4 10.4 14.7 15.5 15.2 13.3 19.2 15.8
15.0
```

如果我们想要在6缸类别中的第三辆车的每加仑英里数（MPG）怎么办？

``` r
> mtl[[2]][3]
[1] 21.4
```

关键是 **mtl[[2]]** 是一个向量，所以如果我们想要该向量的第三个元素，我们就加上 [3]。

或者，

``` r
> mtl$six[3]
[1] 21.4
``` 

顺便说一句，在数据框和列表中都使用美元符号作为分隔符并不是巧合；数据框 *就是* 列表。每一列都是列表的一个元素。所以，例如，

``` r
> mtcars[[1]]
 [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
[31] 15.0 21.4
```

这里我们使用双括号列表符号来获取列表的第一个元素，即数据框的第一列。

> ❄️  轮到你了
>
> 在 **mtcars** 数据中，分别编写代码来完成以下任务（每个任务单独一个代码）：
>  
>  * 打印出 4 气缸汽车中马力的第 5 到第 8 个值。
>  
>  * 打印出 6 气缸汽车中 MPG 的 *最后* 3 个值。这应该完全 *以编程方式* 完成，即不手动设置值。利用 **length** 函数。
>  
>  * 找出数据集中所有汽车的平均马力。
>  
>  * 可以将一个向量除以另一个向量，例如，c(6,12,25) / c(3,2,5) 将得到 c(2,6,5)。编写代码，首先计算马力与重量比的向量，然后计算它们的平均值。（警告：这与平均马力除以平均重量 *不同*。）

## <a name="less7"> </a> 第12课：再看尼罗河数据

在这里，我们将学习几个新概念，以我们的起点 **Nile** 数据为例。

如果你再次看一下我们生成的尼罗河直方图，你会发现最低值和其他值之间有一个间隙。这些非常低的值出现在哪一年？让我们将数据按时间绘制出来：

``` r
> plot(Nile)
```

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/NileOverTime.png)

看起来大概是1912年左右比其他年份低得多。这是错误吗？还是当时发生了一些重大历史事件？这需要更多的资料来查明，但至少R可以告诉我们哪一年或哪些年对应于异常低的水流。以下是方法：

我们从图中看到异常低值低于600。我们可以使用R的 **which** 函数来查看何时发生了这种情况：

``` r
> which(Nile < 600)       
[1] 43
```

和以前一样，请确保理解了这段代码中发生了什么。表达式 **Nile < 600** 产生了100个TRUE和FALSE。然后 **which** 告诉我们其中哪些是TRUE。

所以，这里的元素43是罪魁祸首，对应于年份1871+42=1913。再次强调，我们必须找到补充信息，以决定这是否是一个真实的值还是一个错误，但至少现在我们知道了确切的年份。

当然，由于这是一个小数据集，我们可以只打印出整个数据并目测一下是否有低值。但是如果数据向量的长度是100,000而不是100呢？那么视觉方法就行不通了。

> 📘 专业提示
>
> 记住，编程的目标是自动化任务，而不是手工完成。

> ❄️  轮到你了
>
> 看起来也有一些异常高的值，比如大约在1875年左右。使用这里介绍的技术确定这是哪一年。
>
> 另外，尝试对内置的 **AirPassengers** 数据进行类似的分析。你能猜到为什么会出现这些高峰吗？

这里还有一点：那个 **plot** 函数并不像看起来那么无害。让我们用两个参数而不是一个来运行相同的函数 **plot**：

``` r
> plot(mtcars$wt, mtcars$mpg)
```

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/MTCarsWtMPG.png)

与之前的图相比，其中我们的数据在垂直轴上，时间在水平轴上，现在我们要绘制*两个*向量相对于彼此的图。这使我们能够探索车重和油耗之间的关系。

这里有几个重要的观点。首先，正如我们可能猜到的那样，我们看到较重的车倾向于油耗较高。但是这里还有更多：那个 **plot** 函数相当聪明！

为什么？嗯，**plot** 知道针对不同的输入类型采取不同的操作。当我们给它一个单一的向量时，它会将这些数字绘制成时间（或索引）的函数图。当我们给它两个向量时，它知道要做散点图。

事实上，**plot** 甚至比这更聪明。它注意到 **Nile** 不仅是 **'numeric'** 类型，还是另一个类别 **'ts'**（"时间序列"）：

``` r
> is.numeric(Nile)
[1] TRUE
> class(Nile)
[1] "ts"
```

所以，**plot** 将年份放在水平轴上，而不是索引1,2,3,...

还有一件事：假设我们想知道1925年的水流量。数据从1871年开始，所以1925年比1871年晚了1925 - 1871 = 54年。由于向量的第一个元素是1871年的数据，这意味着1925年的流量在元素1 + 54 = 55处。

``` r
> Nile[55]
[1] 698
```

好吧，但为什么我们要自己做这个算术？我们应该让R来做：

``` r
> Nile[1 + 1925 - 1871]
[1] 698
```

R计算了 1925 - 1871 + 1，得到了55，然后查找了 **Nile[55]** 的值。这是你开始编程之路的一部分--我们尽可能地自动化任务，尽可能少地手工操作。


## <a name="pause1"> </a> 第13课：停下来反思

> 📘 专业提示
>
> 重申之前的一点：
> 如何建造一座房子？当然没有固定的公式。人们有各种工具和材料，目标是将它们以创造性的方式组合起来，生产出最终的结果，即房子。
> 
> 在R中也是如此。这里的工具是各种函数，例如 **mean** 和 **which**，而材料则是数据。然后，人们必须创造性地将它们组合起来，以实现目标，比如挖掘公共交通系统中乘客数量的模式。再次强调，这是一个创造性的过程；没有任何公式可循。但这就是让它变得有趣的地方，就像解决一个谜题一样。
> 
> 而且...我们可以结合各种函数来构建*自己的*函数。这将在未来的课程中介绍。

## <a name="less8"> </a> 第14课：基础R图形介绍

R最伟大的特点之一就是其图形能力。在基础R中有出色的图形功能，还有许多贡献的包，其中最知名的是 **ggplot2** 和 **lattice**。这两者都非常强大，将是未来课程的主题，但现在我们将集中在基础上。

作为我们的示例，我们将使用我从2000年美国人口普查中编制的有关硅谷程序员和工程师的数据集。让我们读取数据并查看前几条记录：

在这里，我们使用 **load** 函数来导入数据，该数据以R的压缩形式存储。这个函数将在[第16课](#less10)中解释，但现在重点是这是必要的，以保留某些变量的R因子结构。

这里 **educ** 和 **occ** 是代码，代表教育水平和不同职业的级别。现在，让我们不去担心具体的代码。（你可以在[人口普查局文件](https://www.census.gov/prod/cen2000/doc/pums.pdf)中找到它们。例如，搜索 "Educational Attainment" 来获取 **educ** 变量的信息。）

让我们从 wage vs. age 的散点图开始：

``` r
> plot(prgeng$age, prgeng$wageinc)
```

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/WageVsAge1.png)

噢，不好了，可怕的黑屏问题！有大约20000个数据点，填充了屏幕的某些部分。因此，让我们只绘制一个随机样本，比如2500个。（还有其他处理此问题的方法，比如使用更小的点或*alpha混合*。）

``` r
> rowNumbers <- sample(1:nrow(prgeng), 2500)
> prgeng2500 <- prgeng[rowNumbers,]
```

回想一下，**nrow** 函数返回参数中的行数，本例中为20090，即 **prgeng** 中的行数。

R的 **sample** 函数就像其名称所暗示的那样。在这里，它随机抽样了1到20090的数字中的2500个。然后我们从 **prgeng** 中提取了这些行，形成一个新的数据框 **prgeng2500**。

> 📘 专业提示
>
> 再次注意，通常将复杂的操作分解为简单的、较小的操作更清晰。我可以写得更紧凑一些
>
> ``` r
> > prgeng2500 <- prgeng[sample(1:nrow(prgeng), 2500),]
> ```
>
> 但这样写起来很难读。我也尽量少使用直接函数组合，更喜欢将
>
> ``` r
> h(g(f(x),3)
> ```
>
> 拆分为
>
> ``` r
> y <- f(x)
> z <- g(y,3)
> h(z)
> ```
>
> （正如前面提到的，我个人认为管道虽然也将复杂的语句分解为较小的语句，但不够清晰，也更难调试，所以我不使用它们。）

所以，这是新的绘图：

``` r
> plot(prgeng2500$age, prgeng2500$wageinc)
```

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/WageVsAge2.png)

请注意，由于我绘制了随机样本行，你得到的可能与我得到的不同。生成的图形大部分相似，但可能不完全相同。

好了，现在我们可以开始了。值得注意的几点：

-  wage 和 age 之间的关系不是线性的，实际上甚至不是单调的。在40岁后，一个人的工资往往会下降。与任何观察性数据集一样，其潜在因素是复杂的，但在硅谷似乎存在年龄歧视问题。（这在各种研究和诉讼中都有很好的文档记录。）

- 请注意图像顶部和底部的水平条纹。人口普查中有些人没有收入（或接近于没有），因为他们没有工作。人口普查对工资设定了最高限额为35万美元（可能是出于隐私考虑），因此更高的数字被截断为该值。

我们可以通过颜色编码来按性别分析：

``` r
> plot(prgeng2500$age, prgeng2500$wageinc, col=prgeng2500$sex)
```

**col** 参数指示我们希望按性别进行颜色编码，在本例中是按性别。它必须是一个R因子。

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/WageVsAge3.png)

红色的点是女性。（以下是详细信息。）她们的工资通常比男性低吗？似乎有这种迹象，但需要进行详细的统计分析（未来课程）。

希望在轴上有更好的标签，也许点更小一些会更好：

``` r
> plot(pe2500$age, pe2500$wageinc, col=as.factor(pe2500$sex), xlab='age', ylab='wage', cex=0.6)
```

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/WageVsAge4.png)

这里的 'xlab' 意思是 "X标签"，'ylab' 类似。参数 'cex = 0.6' 的意思是 "以默认大小的60%绘制点"。

那么，为什么男性的点变成黑色，女性的点变成红色呢？男性编码为1，女性编码为2。所以男性在默认调色板中得到了颜色1，即黑色，而女性得到了颜色2，即红色。

还有许多其他特性。将在未来的课程中介绍更多内容。

> ❄️  该你了
>
> 尝试在不同的数据集上做一些散点图。我建议首先再次使用上述数据，将工资与年龄进行比较，但这次按教育水平进行颜色编码。（顺便说一句，1-9代码表示没有大学学历；10-12表示一些大学课程；13表示学士学位，14表示硕士学位，15表示专业学位，16表示博士学位。）


## <a name="less9"> </a> 第15课：更多关于基本图形的内容

我们还可以在同一张图上绘制多个直方图。但是使用 R 中的 **density** 函数提供的直方图的平滑版本会使图像更有效。让我们比较人口普查数据中男性和女性的工资。

首先我们使用 **split** 函数按性别将数据分开：

``` r
> wageByGender <- split(prgeng$wageinc, prgeng$sex)
> dm <- density(wageByGender[[1]])
> dw <- density(wageByGender[[2]])
```

因此，**wageByGender[[1]]** 现在将是男性工资的向量，类似地 **wageByGender[[2]]** 将包含女性的工资。

**density** 函数不会自动绘制图形；它将绘图信息作为返回值，我们在这里将其赋值给了 **dm** 和 **dw**。我们现在可以绘制图形了：

``` r
> plot(dw, col='red')
> points(dm, cex=0.2)
```

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/MWWages.png)

为什么我们在第二行调用了 **points** 函数而不是 **plot** 函数呢？问题在于再次调用 **plot** 会破坏第一个图形；我们只想在现有图形上*添加点*。

为什么我们先绘制了女性的数据？正如你所见，女性的曲线更高，因此如果我们先绘制男性的曲线，女性的曲线的一部分将被切掉。当然，我们事先不知道这一点，但是通常图形的绘制是一个反复试验的过程，以获得我们真正想要的图像。（在 **ggplot2** 中，这由软件自动处理。）

那么，这张图告诉我们什么呢？女性的峰值出现在略低于50000美元的地方，似乎比男性的峰值低，大约在60000美元左右。在大约125000美元的薪资水平上，男性似乎比女性更多。（黑色曲线高于红色曲线。请记住，曲线只是平滑的直方图，因此，如果一条曲线在，比如168.0，非常频繁出现，那么168.0就是一个非常常见的值。）

> ❄️  轮到你了
>
> 尝试在同一张图上绘制多个类似的曲线，用其他数据。

## <a name="less10"> </a> 第16课：编写你自己的函数

到目前为止，我们已经见过了许多 R 中的内置函数，但最好的部分是——你可以编写*自己的*函数。

回想一下我们之前的一行代码：

``` r
> sum(Nile > 1200)
```

这给了我们 **Nile** 数据中大于1200的元素的计数。现在，假设我们想要这些元素的平均值：

``` r
> gt1200 <- which(Nile > 1200)
> nileSubsetGT1200 <- Nile[gt1200]
> mean(nileSubsetGT1200)
[1] 1250
```

和之前一样，我们也可以写一个更紧凑的版本：

``` r
> mean(Nile[Nile > 1200])
[1] 1250
```

但最好是先一步一步来。让我们看看这些步骤是如何工作的。带有行号用于参考的代码是：

``` r
1  gt1200Indices <- which(Nile > 1200)
2  nileSubsetGT1200 <- Nile[gt1200Indices]
3  mean(nileSubsetGT1200)
```

让我们回顾一下这是如何工作的：

* 在第1行，我们找到了 **Nile** 中大于1200的元素的索引。
* 在第2行，我们提取了由这些元素组成的 **Nile** 子集。
* 在第3行，我们计算了所需的平均值。

但是，我们可能经常需要做这种事情，对许多数据集进行操作等。那么我们有：

> 📘 专业提示
>
> 如果我们有一个经常使用的操作，我们应该考虑为它编写一个函数。
>
> 假设我们想再次进行上述操作，但将1200改为1350。或者，使用我们的 **ToothGrowth** 示例中的 **tg$len** 向量，并将10.2作为我们的下界。我们*可以*继续键入与上述相同的模式，但如果我们经常这样做，最好编写一个函数：
> 
> 下面是我们的函数：
> 
> ``` r
> > mgd <- function(x,d) mean(x[x > d])
> ```
> 
> 这里我使用了一种紧凑的形式方便起见。（否则我需要使用*块*，这将在以后的课程中介绍。）我将其命名为 'mgd'，表示"大于 d 的元素的平均值"，但任何名称都可以。
> 
> 让我们试一试，然后解释一下：
> 
> ``` r
> > mgd(Nile, 1200)
> [1] 1250
> > mgd(tg$len, 10.2)
> [1] 21.58125
> ```
> 
> 这节省了我键入的时间。在第二次调用中，我将不得不键入
> 
> ``` r
> mean(tg$len[tg$len > 10.2])
> ```
> 
> 要长得多。但更重要的是，每次使用时都要考虑操作；通过将其制作成一个函数，我已经准备好在需要时随时使用了。

那么，这一切是如何运作的呢？再次看一下代码：

``` r
> mgd <- function(x,d) mean(x[x > d])
> class(mgd)
[1] "function"
```

这里发生了很多事情。请稍等片刻，让我稍微介绍一下 R 的"理论"：

说出来有点奇怪，但实际上 R 本身内置了一个名为'function'的函数！我们已经见过几个内置的 R 函数，例如 **mean**、**sum** 和 **plot**。嗯，这里有另一个，**function**。我们在这里调用它。它的作用是构建一个函数。是的，正如我喜欢对我的学生们说的那样，

> "名为 **function** 的函数的功能是构建函数！而 **function** 返回的对象的类是 'function'！"

所以，在这一行中

``` r
> mgd <- function(x,d) mean(x[x > d])
```

我们告诉 R，“R，我想要写一个我自己的函数。我想将它命名为 'mgd'；它将有参数 'x' 和 'd'，并且它将计算 'mean(x[x > d])'。请为我构建这个函数。提前谢谢，R！”

在这里，我们调用 **function** 来构建并返回一个 'function' 对象，然后将该返回的对象赋给了 **mgd**。然后我们可以调用后者，就像我们之前看到的那样，为了方便起见，在这里重复一次：

``` r
> mgd(Nile, 1200)
[1] 1250
```

在执行

``` r
> mgd <- function(x,d) mean(x[x > d])
```

***x*** 和 ***d*** 被称为*形式*参数，这意味着它们只是占位符。例如，在

``` r
> mgd(Nile, 1200)
```

我们说：“R，请使用 **Nile** 扮演 ***x*** 的角色，使用 1200 扮演 ***d*** 的角色执行 **mgd**。” 这里的 **Nile** 和 1200 被称为*实际*参数。

与变量一样，我们可以随心所欲地命名函数及其参数。

正如您已经看到的那样，与 R 的内置函数一样，函数通常会有一个返回值。在我们的例子中，我们可以通过编写

``` r
> mgd <- function(x,d) return(mean(x[x > d]))
```

这比上面的版本复杂一些。但是在这里调用 **return** 是不需要的，因为在任何函数中，R 都会返回最后计算的值，这种情况下就是请求的平均值。

我们可以将函数保存起来以便以后使用。其中一种方法是调用 R 的 **save** 函数，它可以用来保存任何 R 对象：

``` r
> save(mgd, file='mean_greater_than_d')
```

该函数现在已经保存在指定的文件中，该文件将位于当前 R 正在运行的文件夹中。我们可以离开 R，然后明天再回来。如果我们从同一个文件夹开始 R，然后运行

``` r
> load('mean_greater_than_d')
```

然后 **mgd** 就会被恢复，可以随时使用了。
（通常这不是人们保存代码的方式，但这是以后课程的主题。）

让我们再写一个函数，这个函数用来找出向量的范围，即最大值和最小值之间的差异。（实际上，R 中已经有一个名为 'range' 的函数，意料之中地命名为 'range'，但仅作为示例，让我们编写我们自己的。）

``` r
> rng <- function(y) max(y) - min(y)
> rng(Nile)
[1] 914
```

在这里，我们利用了内置的 R 函数 **max** 和 **min**。

同样，**rng** 中计算的最后一项是减法，因此它将自动返回，这正是我们想要的。我选择将参数命名为 **y**，但它可以是任何东西。
> ❄️  轮到你了
>
> 试着按照上面所见的方式编写一些简单的函数。
>
> 1. 编写一个名为 **cgd()** 的函数，类似于上面的 **mgd()**，但返回 **x** 中大于 **d** 的元素的计数。
>
> 2. 编写一个名为 **n0(x)** 的函数，返回向量 ***x*** 中的0的数量。（提示：利用 R 的 **==** 和 **sum**。）
>
> 3. 编写一个名为 **hld(x,d)** 的函数，为向量 ***x*** 中小于 ***d*** 的元素绘制直方图。
>
> 4. 编写一个名为 **w(x,y)** 的函数，用于向量参数 **x** 和 **y**，输出与输入长度相同的向量，其中第 **i** 个元素是 **x[i]** 和 **y[i]** 中较大的值，但在这两个数相等的情况下，输出向量中相应的参数为0。


函数是 R 对象，就像向量、列表等一样。因此，我们只需键入它们的名称就可以打印它们！

``` r
> mgd <- function(x,d) mean(x[x > d])
> mgd
function(x,d) mean(x[x > d])
```

事实上，我们可以将它们赋值，例如

``` r
> crazynamedfunction <- mgd
> crazynamedfunction(Nile,1200)
[1] 1250
```

## <a name="less11"> </a> 第17课：'For' 循环

回想一下，之前我们发现 Pima 数据集中有几列包含值为0的数据，这在生理上是不可能的。这些应该被编码为 NA。我们已经看到了如何对葡萄糖变量进行重新编码：

``` r
> pima$glucose[pima$glucose == 0] <- NA
```

但是还有几列类似的情况，我们希望避免重复手工操作。(如果有几百个这样的列呢？) 相反，我们希望通过*编程*来完成，即纯粹通过代码。这可以通过 R 的 **for** 循环结构来实现，这是本单元的主题。

> 📘 专业提示
> 
> 循环是大多数编程语言的主要工具，例如 Python。大多数 R 程序员也经常使用它们，但奇怪的是，一些 R 程序员认为循环应该非常节制地使用，在没有好的 *函数式编程*（FP）替代方案的情况下才使用。
> 
> 对我来说，这毫无意义。循环更容易编码，并且比 FP 代码*更容易调试*。我们将在第28课中介绍 FP，但我不建议初学者在 R 中使用它。
> 
> 我曾经看到一些初学者在 Twitter 上为使用循环而道歉！请写出你感觉舒适的任何风格，而不是成为“时尚的奴隶”。


首先让我们检查哪些列似乎适合进行重新编码。回想一下，这个数据框中有 9 列。

``` r
> for (i in 1:9) print(sum(pima[,i] == 0))
[1] 111
[1] 5
[1] 35
[1] 227
[1] 374
[1] 11
[1] 0
[1] 0
[1] 500
```

在编程世界中，这被称为*'for' 循环*。

'print(etc.)' 被称为循环的*主体*。'for (i in 1:9)' 部分表示：“以 i = 1 执行循环的主体，然后以 i = 2 执行，然后以 i = 3 等等，一直到 i = 9”。

换句话说，上面的代码指示 R 执行以下操作：

``` r
i <- 1
print(sum(pima[,i] == 0))
i <- 2
print(sum(pima[,i] == 0))
i <- 3
print(sum(pima[,i] == 0))
i <- 4
print(sum(pima[,i] == 0))
i <- 5
print(sum(pima[,i] == 0))
i <- 6
print(sum(pima[,i] == 0))
i <- 7
print(sum(pima[,i] == 0))
i <- 8
print(sum(pima[,i] == 0))
i <- 9
print(sum(pima[,i] == 0))
```

这相当于执行

``` r
print(sum(pima[,1] == 0))
print(sum(pima[,2] == 0))
print(sum(pima[,3] == 0))
print(sum(pima[,4] == 0))
print(sum(pima[,5] == 0))
print(sum(pima[,6] == 0))
print(sum(pima[,7] == 0))
print(sum(pima[,8] == 0))
print(sum(pima[,9] == 0))
```

现在，值得回顾一下这些语句的作用，以第一个语句为例。再一次地，**pima[,1] == 0** 生成一个由 TRUE 和 FALSE 组成的向量，每个元素指示第一列对应的元素是否为0。当我们调用 **sum** 时，TRUE 和 FALSE 被视为 1 和 0，因此我们得到了 TRUE 的总数 —— 这是该列中为0的元素的计数，正是我们想要的。

在“for (i in 1:9)...”中的变量 **i** 被称为循环的*索引*。它只是一个普通的 R 变量，所以你可以随意命名它。我们可以将其命名为，比如，**colNumber**。

``` r
for (colNumber in 1:9) print(sum(pima[,colNumber] == 0))
```

一个技术性的问题：为什么我们需要显式调用 **print**？之前不是说在 R 的 '>' 提示符下，只需键入一个表达式，就会自动打印出表达式的值吗？啊是的——但是我们不在 R 提示符下！是的，在上面展开的形式中，

``` r
print(sum(pima[,1] == 0))
print(sum(pima[,2] == 0))
print(sum(pima[,3] == 0))
print(sum(pima[,4] == 0))
print(sum(pima[,5] == 0))
print(sum(pima[,6] == 0))
print(sum(pima[,7] == 0))
print(sum(pima[,8] == 0))
print(sum(pima[,9] == 0))
```

每个命令都将在提示符下发出，并且不需要使用 **print()**。但在 **for** 循环版本中

``` r
for (i in 1:9) print(sum(pima[,i] == 0))
```

我们是从*循环内部*调用 **print**，而不是在提示符下。所以，需要显式调用 **print**。

从循环的输出中我们可以看到，在这个数据集中有许多错误的0，比如在第3列中有35个。我们可能已经忘记了哪一列是哪一列，所以让我们使用另一个内置的 R 函数来看看：



**翻译结果中出现了一些错误，我将其修正如下：**

这被称为在编程世界中的*'for' 循环*。

'print(etc.)' 被称为循环的*主体*。'for (i in 1:9)' 部分表示：“执行循环的主体时，i = 1，然后 i = 2，接着 i = 3，依此类推，直到 i = 9”。

换句话说，上面的代码指示 R 执行以下操作：

```r
i <- 1
print(sum(pima[,i] == 0))
i <- 2
print(sum(pima[,i] == 0))
i <- 3
print(sum(pima[,i] == 0))
i <- 4
print(sum(pima[,i] == 0))
i <- 5
print(sum(pima[,i] == 0))
i <- 6
print(sum(pima[,i] == 0))
i <- 7
print(sum(pima[,i] == 0))
i <- 8
print(sum(pima[,i] == 0))
i <- 9
print(sum(pima[,i] == 0))
```

这相当于执行

```r
print(sum(pima[,1] == 0))
print(sum(pima[,2] == 0))
print(sum(pima[,3] == 0))
print(sum(pima[,4] == 0))
print(sum(pima[,5] == 0))
print(sum(pima[,6] == 0))
print(sum(pima[,7] == 0))
print(sum(pima[,8] == 0))
print(sum(pima[,9] == 0))
```

因此，这给我们提供了每列中0的数量的报告。

循环体的每次运行称为一个*迭代*。我们有一个 **i=1** 的迭代，然后一个 **i=2**，依此类推。

现在，值得回顾一下这些语句的作用，以第一个语句为例。再一次地，**pima[,1] == 0** 生成一个由 TRUE 和 FALSE 组成的向量，每个元素指示第一列对应的元素是否为0。当我们调用 **sum** 时，TRUE 和 FALSE 被视为 1 和 0，因此我们得到了 TRUE 的总数 —— 这是该列中为0的元素的计数，正是我们想要的。

在“for (i in 1:9)...”中的变量 **i** 被称为循环的*索引*。它只是一个普通的 R 变量，所以你可以随意命名它。我们可以将其命名为，比如，**colNumber**。

```r
for (colNumber in 1:9) print(sum(pima[,colNumber] == 0))
```

一个技术性的问题：为什么我们需要显式调用 **print**？之前不是说在 R 的 '>' 提示符下，只需键入一个表达式，就会自动打印出表达式的值吗？啊是的——但是我们不在 R 提示符下！是的，在上面展开的形式中，

```r
print(sum(pima[,1] == 0))
print(sum(pima[,2] == 0))
print(sum(pima[,3] == 0))
print(sum(pima[,4] == 0))
print(sum(pima[,5] == 0))
print(sum(pima[,6] == 0))
print(sum(pima[,7] == 0))
print(sum(pima[,8] == 0))
print(sum(pima[,9] == 0))
```

每个命令都将在提示符处发出。但在 **for** 循环版本中

```r
for (i in 1:9) print(sum(pima[,i] == 0))
```

我们是从*循环内部*调用 **print**，而不是在提示符下。所以，需要显式调用 **print**。

从循环的输出中我们可以看到，在这个数据集中有许多错误的0，比如在第3列中有35个。我们可能已经忘记了哪一列是哪一列，所以让我们使用另一个内置的 R 函数来看看：

```r
> colnames(pima)
[1] "pregnant"  "glucose"   "diastolic" "triceps"   "insulin"   "bmi"      
[7] "diabetes"  "age"       "test"     
```

啊，所以第3列是 'diastolic'。

由于有些女性确实没有怀孕过，所以该列不应该重新编码。而最后一列表示糖尿病检测结果是否阳性，1 代表是，0 代表否，因此这些0也是合法的。

但是第 2 到第 6 列中的0应该被重新编码为 NA。由于*这是一个重复性操作，建议也使用 **for** 循环*：

```r
> for (i in 2:6) pima[pima[,i] == 0,i] <- NA
```

你可能会觉得这行代码有些挑战性，但请耐心一点，和 R 中的其他内容一样，你会发现自己只需耐心就能够掌握它。下面是代码：

首先，让我们以更容易理解的形式写出它：

```r
> for (i in 2:6) {
+    zeroIndices <- which(pima[,i] == 0)
+    pima[zeroIndices,i] <- NA
+ }
```

你可以逐行在提示符下输入循环或函数等代码，就像我们在这里所做的一样。R 会使用它的 '+' 提示符（我没有键入它）来提醒我，我仍然在输入代码中。（在 '}' 后面，我只需按 Enter 键告诉 R 我已经完成了。）

在这里，我打算将循环的主体定义为一个包含两条语句的 *块*，因此我需要使用 '{' 和 '}' 将它们括起来。

按照上述逐行输入代码的方式是创建简短循环或函数的快速方便的方法。但通常，我们会使用文本编辑器，可以是独立的编辑器如著名的 Vim，也可以是集成开发环境（IDE）如 RStudio。但现在，我们将按照上述方式进行工作。

为了方便起见，下面是代码本身，没有 '+' 符号。你可以将其复制粘贴到 R 中，结果与上面一样。

```
for (i in 2:6) {
   zeroIndices <- which(pima[,i] == 0)
   pima[zeroIndices,i] <- NA
}
```

所以，该块（这里有两行）将在 **i** = 2，然后是 3、4、5 和 6 时执行。下面这行代码：

```r
zeroIndices <- which(pima[,i] == 0)
```

确定第 **i** 列中的 0 所在的位置，然后这行代码：

```r
 pima[zeroIndices,i] <- NA
```

将这些 0 替换为 NA。

> 📘 专业提示
>
> 注意，我对块中的两行进行了缩进。这不是必需的，但是在编写清晰的代码时是很好的做法，因为这样可以很容易地识别出块，无论是你还是其他人阅读代码。

有时我们的代码需要提前退出循环，我们可以使用 R 的 **break** 结构来实现。比如，我们正在计算 1、2、3、... 的数字的立方和，并且出于某种原因想要确定哪个和 —— 如果有的话 —— 是首次超过 **s** 的：

```r
> f
function(n,s) 
{
   tot <- 0
   for (i in 1:n) {
      tot <- tot + i^3
      if (tot > s) {
         print(i)
         break
      }
      if (i == n) print('failed')
   }
}
> f(100,345)
[1] 6
> f(5,345)
[1] "failed"

```

如果我们的累积总数达到目标，我们就离开循环。

在这里，我们创建的函数 **f()** 的创建过程没有显示出来，但请注意在创建完成后我们做了什么——在 R 提示符下输入函数的名称，然后它确实打印出来了！函数是对象，R 已经被设计成这些对象可以被打印出来。

让我们看看代码做了什么；其中有相当多的内容。

首先，注意 **if** 语句。如果当前总数大于 **s**，我们执行随后的代码块（**print** 和 **break**），这样我们就打印出了使我们超出总数的 **i** 的值，然后通过执行 **break** 离开循环。由于在此函数中的循环后面没有其他代码，因此我们退出该函数。

另一方面，如果当前总数不大于 **s**，我们跳过该代码块，继续执行下一个语句。后者实际上是另一个 **if** 语句。它检查 **i** 是否等于 **n**。如果 **i** 等于 **n**，意味着循环在 **tot** 从未超过 **s** 的情况下结束，因此打印 'failed'。

更好的方法是使用 'while' 循环，稍后在本教程中介绍。

## <a name="ftnbl"> </a> 第18课：带有块的函数

在定义函数时，块通常起着关键作用。让我们将 Loops 课程中的上述代码概括起来，编写一个函数，在通用数据框中替换指定列中的0为NA，而不仅仅是像之前那样只针对 **pima**。

（我们在此显示了行号以方便阅读。）

这里的形式参数 **d** 是要处理的数据框，**cols** 指定要替换0的列。

循环逐列遍历 **d**。因为 **d[,j]** 表示 **d** 的第 **j** 列的所有内容，所以 **which(d[,j] == 0)** 将给出在该列中元素为0的索引。这些索引反过来又是 **d** 中的行号。换句话说，**NArows** 是一个包含列 **j** 中0行的行号的向量。然后，在第5行，我们用NA替换了列 **j** 中找到的0。在继续之前，请在脑海中思考一下这个小例子：

```r
> d <- data.frame(x=c(1,0,3),y=c(0,0,13)) 
> d
  x  y
1 1  0
2 0  0
3 3 13
> which(d[,2] == 0)
[1] 1 2  # 是的，列2中的0元素位于索引1和2处
```

回到上面的循环代码，注意当我们到达第7行时，我们已经完成了循环，并退出了循环。所以，我们准备好返回 **d** 的新值了。回想一下，我们可以通过表达式 **return(d)** 来实现这一点，但是我们可以节省一些输入时间，只需写 'd' 即可。这个值成为了最后计算的值，并且 R 会自动返回最后的值。

我们可以在 Pima 数据上使用这个函数：

```r
> pima <- zerosToNAs(pima,2:6)
```

这里有一个重要的微妙之处。所有这些将产生一个新的数据框，而不是改变 **pima** 本身。这看起来很奇怪；**d** 不是在改变吗，而且 **d** 不是和 **pima** 相同吗？嗯，并不是；**d** 只是 **pima** 的一个 *独立副本*。所以，当 **d** 改变时，**pima** 并没有改变。因此，如果我们希望 **pima** 改变，我们必须将函数的输出重新分配给 **pima**，就像我们上面所做的那样。

> ❄️  轮到你了
>
> 编写一个调用形式为 **countNAs(dfr)** 的函数，它打印数据框 **dfr** 中每列的NA数目。您需要使用内置的 **is.na** 函数；在 R 命令提示符下执行 **is.na(c(5,NA,13,28,NA))** 来查看它的功能。在一个你创建的小型人工数据集上测试它。

## <a name="edt"> </a> 第19课：文本编辑和集成开发环境（IDE）

在尝试上面的 **zeroToNAs** 函数时，您可能使用了计算机的鼠标将本教程中的内容复制粘贴到您的机器上。然后，您的屏幕将如下所示：

但这是笨拙的。逐行输入是费时且容易出错的。如果我们要更改代码怎么办？难道我们必须重新输入整个代码吗？我们真的需要一个*文本编辑器*来解决这个问题。就像我们编辑报告一样，我们也可以编辑代码。

这里有几种选择：

1. 如果您已经在使用一个集成开发环境（IDE），比如 RStudio，您可以直接在指定的窗格中进行编辑。

2. 如果您使用的是外部编辑器，比如 vim 或 emacs，只需打开一个新文件并使用该工作区即可。

3. 对于不使用这些的人，我们将使用 R 的内置 **edit** 函数。

对于现在来说，选项3是可以接受的，但最终您会想要使用选项1或2。您可能希望现在开始使用其中之一，然后再继续前进。

在本文档末尾的<a href="#ide">附录</a>中，我们有关于如何开始使用 RStudio 的详细信息。**警告：** 正如之前所指出的，一个主要的 R 用户组将 RStudio 描述为“令人不知所措”。但如果您抵制（或他人的力劝）一次学会所有内容的诱惑，它其实很容易。只要您在附录中坚持基础知识，您会发现使用起来非常容易；稍后您可以学习高级技巧。

考虑以下玩具例子：

它找到输入的和与差，并将它们作为一个两元素向量返回。

如果您正在使用 RStudio 或外部编辑器，请将上述代码复制粘贴到一个空文件的工作区中。

或者，要使用 **edit** 创建 **f**，我们将执行以下操作：

这会调用文本编辑器，这取决于您的机器。它会在您的 R 窗口中直接打开您的文本编辑器。在编辑器中键入函数代码，然后使用编辑器的保存命令保存。


**重要提示：** 即使您不使用 **edit**，了解上述命令的工作原理也很重要。

a. **edit** 本身是一个函数。它的返回值是您键入的代码！

b. 该代码然后被分配给 **f**，然后您现在可以调用它

如果您想要更改函数，在使用 RStudio/外部编辑器的情况下，只需在那里编辑它。在使用 **edit** 的情况下，输入以下内容：

```r
> f <- edit(f)
```

这将再次打开文本编辑器，但这次会显示当前 **f** 的代码。您可以按照需要编辑代码，然后像以前一样，结果会重新分配给 **f**。

然后如何运行代码，比如计算 **f(5,2)**？

* 如果您是使用 **edit** 创建 **f**，那么执行如下：

```r
> f(5,2)
```

* 如果您使用了外部文本编辑器，比如将代码保存到文件 **a.R** 中，那么执行以下操作：

```r
> source('a.R')
```

加载文件，然后您就可以像上面那样运行。

* 在 RStudio 中，点击“Source”，然后像上面那样运行。


## <a name="ifelse"> </a> 第20课：If、Else、Ifelse

在上面的人口普查数据示例中，曾经说明教育代码0-9都对应于根本没有大学教育。例如，9表示高中毕业，而6表示受教育程度到10年级。（当然，几乎没有程序员和工程师的教育程度低于大学，但这个数据集是从普通数据中提取出来的。）13表示学士学位。

假设我们希望按照受教育程度对前面课程中的工资-年龄图进行颜色编码。让我们将所有代码合并到13以下，将它们都归为代码12。

直截了当但过于复杂、潜在速度较慢的方法如下：

```r
> head(pe$educ,15)
 [1] 13  9  9 11 11 11 12 11 14  9 12 13 12 13  6
> for (i in 1:nrow(pe)) {
+    if (pe$educ[i] < 13) pe$educ[i] <- 12 
+ }
> head(pe$educ,15)
 [1] 13 12 12 12 12 12 12 12 14 12 12 13 12 13 12
```

为了教学上的清晰，我插入了“之前和之后”的代码，使用 **head** 来显示 **educ** 确实在应该更改的地方发生了更改。

**if** 语句的工作方式几乎就像英语中的单词“if”一样。首先，**i** 在循环中被设置为1，所以 R 将测试 **pe$educ[1]** 是否小于13。如果是，它将重新设置该元素为12；否则，不做任何操作。然后对 **i** 等于2，以此类推。您可以看到上面的例子中，例如，**pe$educ[2]** 确实从9更改为12。

但是有一种更聪明（而且实际上更标准）的方法可以做到这一点（重新阅读数据文件以确保代码运行正常）：

```r
> edu <- pe$educ
> pe$educ <- ifelse(edu < 13, 12, edu)
```

（再次，为了清晰起见，我们将本来可以是一行的代码分成了两行。）

那么这是如何工作的呢？如上所示，R 的 **ifelse** 函数有三个参数，其返回值是一个新的向量，在这种情况下，我们重新分配给了 **pe$educ**。这里，**edu < 12** 生成一个由 TRUE 和 FALSE 组成的向量。对于每个 TRUE，我们将输出的相应元素设置为12；对于每个 FALSE，我们将输出的相应元素设置为 **edu** 中的相应元素。这正是我们希望发生的事情。

所以，我们现在可以绘制所需的图形：

```r
> plot(pe$age, pe$wageinc, col = edu)
```

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/WageAgeEdu.png)

顺便说一句，普通的 **if** 也可以与 **else** 配对使用。例如，假设我们需要根据 **x** 是否小于3 来将 **y** 设置为-1 或 1。我们可以写成：

```r
if (x < 3) y <- -1 else y <- 1
```

还有一个重要的点：在上面的示例中使用 **ifelse** 而不是循环称为*向量化*。这个名字来自于 **ifelse** 在向量上操作，而在循环中，我们逐个处理一个个单独的元素。

向量化的代码通常比基于循环的代码要紧凑得多，就像这里的情况一样。在某些情况下，尽管当然不是所有情况，向量化版本会快得多。

顺便说一下，注意上面的注释：“**ifelse** 在向量上操作”。让我们以这一点为前提重新审视上面的声明。

```r
> pe$educ <- ifelse(edu < 13, 12, edu)
```

有一个重要的点需要记住，即13和12都会被重复使用，正如之前解释的一样。 **edu** 向量长度为20090个元素，所以为了逐个元素地进行比较，13必须被重复为一个由20090个值为13的元素组成的向量。对于12也是一样的。

这里有另一个例子。假设我们希望将 **Nile** 数据重新编码为一个新的向量 **nile**，其值为1、2和3，分别表示小于800、在800到1150之间（包括1150）、大于1150的情况。我们可以这样做：

```r
> nile <- ifelse(Nile > 1150, 3, 2)
> nile <- ifelse(Nile < 800, 1, nile)
# 检查一下
> table(nile)
nile
 1  2  3 
26 62 12 
```

在第一次调用 **ifelse** 后，向量 **nile**（不是 **Nile**；变量名等是区分大小写的）由2和3组成。3是正确的，但2需要进一步处理，因此是第二次调用。

但是让我们仔细看看第二次调用，以复习我们之前看到的一些内容：

1. 表达式 **Nile > 1150** 评估为一个由100个 TRUE 和 FALSE 组成的向量。

2. 然后，单一值 800 被重复为一百个 800，以建立 '<'。让我们将该 '<' 操作的结果称为 w。

3. 接着，**ifelse(Nile < 800, 1, nile)** 的意思是：“对于向量 w 中的每个为 TRUE 的元素，写下一个 1；对于每个为 FALSE 的元素，写下 **nile** 中相应的值。”

恭喜！通过使用 **for** 和现在的 **ifelse**，你真正开始了编程业务。在接下来的课程中，我们将经常使用它们。

> ❄️  轮到你了
>
> 写一个 **for** 循环版本的上面的 **Nile** 示例。


## <a name="keepfit"> </a> 第21课：专业运动员保持健康吗？

许多人随着年龄增长而增加体重。但是专业运动员呢？毕竟他们应该保持健康。让我们使用专业棒球运动员的数据来探讨这个问题。（数据集由 UCLA 统计系提供。）

```r
> load(url('https://github.com/matloff/fasteR/blob/master/data/mlb.RData?raw=true'))
> head(mlb)
             Name Team       Position Height Weight   Age PosCategory
1   Adam_Donachie  BAL        Catcher     74    180 22.99     Catcher
2       Paul_Bako  BAL        Catcher     74    215 34.69     Catcher
3 Ramon_Hernandez  BAL        Catcher     72    210 30.78     Catcher
4    Kevin_Millar  BAL  First_Baseman     72    210 35.43   Infielder
5     Chris_Gomez  BAL  First_Baseman     73    188 35.71   Infielder
6   Brian_Roberts  BAL Second_Baseman     69    176 29.39   Infielder
> class(mlb$Height)
[1] "integer"
> class(mlb$Name)
[1] "factor"
```

（和往常一样，在读入数据后，我们环顾四周，浏览了前几条记录，并查看了几种数据类型。）

现在，作为评估随着时间增长体重增加问题的第一次尝试，让我们查看每个年龄组的平均体重。为了进行分组，我们首先将年龄四舍五入到最近的整数，使用 R 函数 **round**，这样例如 21.8 就会变为 22，35.1 就会变为 35。

让我们使用 R 的 **table** 函数来探索数据。

```r
> age <- round(mlb$Age)
> table(age)
age
 21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40 
  2  20  58  80 103 104 106  84  80  74  70  44  44  32  32  22  20  12   6   7 
 41  42  43  44  49 
  9   2   2   1   1 
```

毫不奇怪，极端年龄的球员很少 —— 例如只有两个 21 岁和一个 49 岁的。因此，我们在这些年龄水平上没有很好的抽样，可能希望将它们排除在外（我们很快就会这样做）。

那么，我们如何找到组平均值呢？这是 **tapply** 函数的完美应用，就像我们之前使用它一样：

```r
> taout <- tapply(mlb$Weight, age, mean)
> taout
      21       22       23       24       25       26       27       28 
215.0000 192.8500 196.2241 194.4500 200.2427 200.4327 199.2925 203.9643 
      29       30       31       32       33       34       35       36 
199.4875 204.1757 202.8429 206.7500 203.5909 204.8750 209.6250 205.6364 
      37       38       39       40       41       42       43       44 
203.2000 200.6667 208.3333 207.8571 205.2222 230.5000 229.5000 175.0000 
      49 
188.0000 
```


总结一下：对 **tapply** 的调用指示 R 根据 **age** 向量中的相应元素拆分 **mlb$Weight** 向量，然后在每个结果组中找到平均值。这给了我们我们想要的，即每个年龄组的平均体重。

那么，上面是否看到了时间趋势呢？再次强调，我们应该排除极端低龄和高龄，我们不能期望随着时间的推移出现完全一致的上升趋势，因为每个平均值都受到抽样变异的影响。（我们将数据视为所有专业棒球运动员，包括过去、现在和未来的人口的样本。）尽管如此，似乎确实存在轻微的上升趋势；年龄较大的球员往往体重更重！

顺便提一下，**taout** 是一个向量，但是带有附加信息，即元素有名称，在这种情况下是年龄。实际上，如果需要，我们可以将这些名称提取到它自己的向量中：

```r
> names(taout)
 [1] "21" "22" "23" "24" "25" "26" "27" "28" "29" "30" "31" "32" "33"
"34" "35"
[16] "36" "37" "38" "39" "40" "41" "42" "43" "44" "49"
```

让我们根据年龄绘制平均值。我们将仅绘制基于更大数据量的平均值。因此，我们将其限制为，例如，年龄为 23 到 35 岁之间的年龄组，所有这些年龄组的平均值都是基于至少 30 名球员的。该年龄范围对应于 **taout** 的第 3 到第 15 个元素，所以这里是绘图的代码：

```r
> plot(23:35, taout[3:15])
```

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/MLB.png)

的确，看起来存在随时间增长的趋势。球员们应该更加小心！

（尽管这远远超出了本教程的范围，本教程是关于 R 而不是统计学的，但应该指出需要谨慎解释回归系数。例如，较重的球员可能倾向于拥有更长的职业生涯。如果是这样的话，将我们的线性形式拟合到具有许多年长、体重较重的球员的数据可能会误导地暗示大多数个体球员随着年龄增长体重增加。当然，他们会坚持认为增加的体重全都是肌肉。:-)）

再次注意，**plot** 函数注意到我们提供给它的是两个参数而不是一个，因此绘制了一个二维散点图。例如，在 **taout** 中，我们看到 25 岁的平均体重是 200.2427，因此图表中有一个点，坐标为 (25,200.2427)。

> ❄️ 轮到你了
>
> 有许多小实验可以在这个数据集上进行。例如，使用 **tapply** 找到每个位置的平均体重； "肥硕" 捕手的刻板印象准确吗，即该位置的平均体重是否高于其他位置？另一个建议：绘制每个年龄组的球员数量，以可视化大多数球员所在的年龄。


## 第22课: 线性回归分析，I

在上一课的图片中，看起来我们可以通过这些点的云绘制一条穿过它们的直线，这条直线相当拟合这些点。这就是线性回归分析的作用所在。

当然，我们在这里不能详细讨论统计方法，但至少了解一个好的定义集将会有所帮助：

> 如前所述，我们将数据视为所有球员（过去、现在和将来的）的（概念上的）总体样本。因此，每个年龄组都有一个总体平均体重。假定这些总体均值，当以年龄为横坐标绘制时，位于某条直线上。

换句话说，我们的模型是

平均体重 = &beta;<sub>0</sub> + &beta;<sub>1</sub> 身高

其中 &beta;<sub>0</sub> 和 &beta;<sub>1</sub> 是总体回归线的截距和斜率。

因此，我们需要使用数据来估计那条直线的斜率和截距，R 的 **lm**（"线性模型"）函数可以为我们完成这项工作。我们将使用原始数据集，因为带有舍入年龄的数据集只是用来指导我们的直觉。

``` r
> lm(Weight ~ Age,data=mlb)

Call:
lm(formula = Weight ~ Age, data = mlb)

Coefficients:
(Intercept)          Age  
   181.4366       0.6936  
```

这里的调用指示 R 估计了基于 **mlb** 数据的体重与年龄的回归线。

因此，估计的斜率和截距分别为 0.6936 和 181.4366。（请记住，这些只是样本估计值。我们不知道总体值。）R 有一种方式可以通过它绘制直线，在我们的散点图上叠加：

``` r
> abline(181.4366,0.6936)
```

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/Add_abline.png)

> ❄️  你来试试
>
> 在 **mtcars** 数据中，拟合一个回归模型，将 MPG 对 weight 进行回归；额外增加 100 磅重量的估计效果是什么？

## 第23课: S3 类

> 📘 专业提示
>
> 记住，计算机的目的是减轻我们的工作负担。我们应该避免做计算机可以完成的事情。例如，考虑上一课的图表：我们曾经键入了
>
> ``` r
> > abline(181.4366,0.6936)
> ```
>
> 但我们实际上不应该手动键入这些数字，而且我们也不必这样做。这是为什么：

如前所述，R 是一种*面向对象的语言*。一切都是*对象*，每个对象都有一个*类*。其中一种最常见的类结构称为'S3'。

当我们调用 **lm** 时，它会返回一个 'lm' 类的 S3 对象：

``` r
> lmout <- lm(Weight ~ Age,data=mlb)
> class(lmout)
[1] "lm"
```

快速查看对象内容的一个方便方法是通过 **str** 函数：

``` r
> str(lmout)
List of 12
 $ coefficients : Named num [1:2] 181.437 0.694
  ..- attr(*, "names")= chr [1:2] "(Intercept)" "Age"
...
...
 - attr(*, "class")= chr "lm"
```

这里我们使用 ... 表示我们省略了很多输出内容。但是即使在这个摘录中，有几点值得注意：

1. 这里我们的 **lmout** 对象是一个 R 列表（这是 S3 对象的性质）。该 R 列表有 12 个元素。

2. 但它有一个额外的 *属性*，即类名，在本例中是 **'lm'**。（因此，R 的设计者简单地选择以函数命名类，这并不总是如此。）

3. 这个 R 列表的第一个元素被命名为 'coefficients'，它是一个包含斜率和截距的向量。

因此，我们不必手动键入斜率和截距。

``` r
> cfs <- lmout$coefficients
> abline(a = cfs[1], b = cfs[2])
```

顺便说一句，**abline** 实际上是一个*通用*函数，就像 **print** 和 **plot** 一样。也就是说，它适用于各种类型的对象类。其中一种类就是 'lm'！因此，如果我们想聪明一点，我们可以使用这种方法将我们的直线添加到图表中：

``` r
> abline(lmout)
```

**abline** 的内部代码会识别 **lmout** 是 'lm' 类，因此知道它可以在 **lmout** 列表的 **coefficients** 元素中找到系数。这样就节省了很多工作！

现在，关于我们最初的问题 -- 随着年龄增长，棒球运动员会增加体重吗？答案似乎是肯定的；每增加一岁，估计的平均体重增加约 0.7 磅。这在 10 年内约为 7 磅，相当显著。

再次强调，这只是一个估计 -- 181.437 和 0.694 是未知总体值 &beta;<sub>0</sub> 和 &beta;<sub>1</sub> 的估计值，是从样本数据中生成的。通过计算*置信区间*，我们可以对这个估计的准确性有所了解，但我们将把它留给统计课程。

但是我们现在可以做更多的事情。有人可能会问，我们不应该考虑球员的身高吗，而不仅仅是他的年龄吗？毕竟，个子高的人往往体重更重。是的，我们应该这样做：

``` r
> lmo <- lm(Weight ~ Height + Age, data=mlb)
> lmo

Call:
lm(formula = Weight ~ Height + Age, data = mlb)

Coefficients:
(Intercept)       Height          Age  
  -187.6382       4.9236       0.9115  
```

在这里，我们指示 R 查找使用身高和年龄作为预测因子的体重的估计回归函数。'+' 并不表示加法；它只是我们回归规范中的预测因子身高和年龄之间的分隔符。

因此，新模型是

平均体重 = &beta;<sub>0</sub> + &beta;<sub>1</sub> 身高 + &beta;<sub>2</sub> 年龄

这表示：

    估计的平均体重 = -187.6382 + 4.9236 身高 + 0.9115 年龄

因此，在这种更精细的分析下，情况更加悲观；球员平均每年增加约 0.9 磅。顺便说一下，身高额外增加一英寸平均相当于额外增加约 4.9 磅体重；更高的球员确实更重，正如我们所推测的那样。

<span style="color:red">警告：</span>
虽然这不是一个专门的统计教程，但应该注意一个重要的观点。回归分析有两个目标，描述和预测。我们上面的分析旨在前者 -- 我们想要*描述*职业棒球运动员健康问题的性质。正如我们所见，当另一个预测因子添加到模型中时，一个系数可能会发生相当大的变化，甚至可以改变符号（"辛普森悖论"）。例如，假设较矮的球员往往拥有更长的职业生涯。如果我们在模型中*不*包含身高，那么这种省略可能会使年龄系数偏向下方。因此，在描述设置中解释系数时必须非常小心。对于预测来说，这不是那么大的问题。

> ❄️  你的回合
>
> 在 **mtcars** 数据中，拟合一个关于汽车油耗（MPG）对车重和马力的线性模型；对于固定的马力，额外增加 100 磅的重量的估计效果是什么？


## 第24课: 棒球运动员分析（续）

本课程将会稍微长一些，更注重细节。但它将让你在许多早期主题上获得更多练习，也会为你带来一些新的 R 函数。在这节课上花费额外的时间将会带来可观的回报。

我们可能想知道球员位置之间的回归线是否有很大的差异。（一个更统计的方法是在模型中包含*交互项*。）让我们首先看看哪些位置被列出：

``` r
> table(mlb$PosCategory)
   Catcher  Infielder Outfielder    Pitcher 
        76        210        194        535 
```

让我们分别为每种位置类型拟合回归线。

有各种各样的方法可以做到这一点，涉及到不同程度的避免循环。但我们将保持简单，这会更清晰。

首先，让我们按位置拆分数据。你可能首先认为可以使用 **split** 函数轻松实现这一点，但这不起作用，因为该函数用于拆分向量。在这里，我们希望拆分一个数据框。

那么可以做些什么呢？我们需要在这里进行创造性的思考。一个解决方案是这样的：

我们需要确定捕手的行号、内野手的行号等等。所以我们可以取所有的行号，**1:nrow(mlb)**，并对该向量应用 **split**！

``` r
> rownums <- split(1:nrow(mlb),mlb$PosCategory)
```

**mlb** 有 1015 行，所以这句话的意思是：“取 1:1015 的行号，并根据 **mlb** 的 **PosCategory** 列进行拆分。” 按照这种方式，得到的行号堆就是捕手的行号，然后是内野手的行号，以此类推。

和往常一样，在进行了类似复杂操作之后，我们应该查看一下结果：

``` r
> str(rownums)
List of 4
 $ Catcher   : int [1:76] 1 2 3 35 36 66 67 68 101 102 ...
 $ Infielder : int [1:210] 4 5 6 7 8 9 37 38 39 40 ...
 $ Outfielder: int [1:194] 10 11 12 13 14 15 16 43 44 45 ...
 $ Pitcher   : int [1:535] 17 18 19 20 21 22 23 24 25 26 ...
```

所以输出是一个 R 列表；这并不奇怪，因为我们事先知道 **split** 会产生一个 R 列表。同样并不奇怪，列表的元素被命名为 "Catcher" 等等。因此，例如，第三个外场手在数据框的第 12 行。


> 📘 专业提示
>
> 这里的想法，使用 **split** 在 **1:nrow(mlb)** 上，有点把戏。实际上，对于经验丰富的 R 程序员来说，这是一个常见的策略，但你可能会问，“一个新手怎么会想到这个主意呢？”  
>
> 答案就像在这里已经多次指出的那样，编程是一个创造性的过程。这是一个创造性的解决方案。
>
> 创造力可能不会很快产生！当然，网络上有许多论坛可以提问，例如 Stack Overflow，但*抵制立即这样做的诱惑*。不要放弃！你对问题的思考越多，你的技能将会越来越熟练，即使有时你会一无所获。

现在，记住，R 列表的一个好处是我们可以以不同的方式引用它们的元素。例如，上面的第一个元素可以是 **rownums$Catcher**、**rownums[['Catcher']]** 或 **rownums[[1]]** 中的任何一个，这种多样性很棒，因为我们可以使用后两种形式来编写循环。

这里正是我们需要循环的地方。（也可以使用*函数式编程*来实现，我们将在后面的课程中介绍。）我们想要为每个位置调用 **lm** 四次，每次一种位置。我们可以这样做，比如说，使用以以下方式开始的循环：

``` r
for (i in 1:4)
```

来遍历这四种位置类型，但如果我们使用名称会更清晰：

``` r
for (pos in c('Catcher','Infielder','Outfielder','Pitcher'))
```

回想一下 'for' 循环的形式

``` r
for (variable in vector)...
```

现在我们不再有一个数字向量，例如上面的 1:4，而是有一个字符向量，其中向量的每个元素都是一个字符字符串，即 'Catcher'、'Infielder' 等等，但原则是相同的。

我们可以在循环的主体中有 **lm** 和 **print** 的调用。但让我们再高级一点，用输出构建一个数据框。我们将从一个空框架开始，并不断添加行。

我们的代码是

``` r
posNames <- c('Catcher','Infielder','Outfielder','Pitcher')
m <- data.frame()
for (pos in posNames) {
   posRows <- rownums[[pos]]
   lmo <- lm(Weight ~ Age, data = mlb[posRows,])
   newrow <- lmo$coefficients
   m <- rbind(m,newrow)
}
```

这是输出结果：

``` r
> m
  X180.828029016113 X0.794925225995348
1          180.8280          0.7949252
2          170.2466          0.8589593
3          176.2884          0.7883343
4          185.5994          0.6543904
```

这里需要注意的一些关键点。

* 整体策略是从一个空的数据框开始，然后不断向其添加行，每个球员位置都有一行回归系数。

* 为了将行添加到 **m** 中，我们使用了 R 的 **rbind**（"行绑定"）函数。表达式 **rbind(m,newrow)** 形成一个新的数据框，通过将 **newrow** 添加到 **m** 并返回结果。这里我们将结果重新赋值给 **m**，这也是一个常见的操作。（请仔细注意：**rbind** 操作并没有改变 **m**；它只是创建了一个新的数据框。要更新 **m**，我们需要将该新的数据框分配给 **m**。）顺便说一句，还有一个 **cbind** 函数用于列。

* 在对 **lm** 的调用中，我们使用了 **mlb[rownums[[pos]],]**，而不是之前的 **mlb**，因为这里我们想要在每个位置子组上拟合一条回归线。因此，我们只关注 **mlb** 中位置等于当前 **pos** 值的那些行。

所以，发生的事情是：**m** 最初是一个空的数据框。然后，循环，对于第一次迭代，将 **pos** 设置为 'Catcher'。然后将为 **mlb** 中为捕手的行拟合一条回归线。这个拟合结果从 **lm** 返回给我们，我们提取系数，将它们附加到 **m** 的末尾。

> 📘 专业提示
>
> 这是 R（以及大多数其他语言）中非常常见的*设计模式*，在循环中逐行构建数据框（或类似结构）。

输出很好，两列对齐了。但是这些列名太糟糕了，行标签应该比 1、2、3、4 更友好。我们可以修复这些问题：

``` r
> row.names(m) <- posNames
> names(m) <- c('intercept','slope')
> m
           intercept     slope
Catcher     180.8280 0.7949252
Infielder   170.2466 0.8589593
Outfielder  176.2884 0.7883343
Pitcher     185.5994 0.6543904
```

这里发生了什么？我们之前看到了内置的 **row.names** 函数，所以设置行名很容易。但是列名呢？回想一下，数据框实际上是一个 R 列表，由几个相同长度的向量组成，它们形成了列。因此，**names(m)** 就是列的名称。

所以通过在这里稍微调整一下，我们得到了一些格式很好的输出。此外，我们现在已经将结果存储在了一个数据框中，以供进一步使用。例如，我们可能希望在同一图上绘制这四条线，我们将使用数据框的行作为输入。

还可以再精细一点。看看这一行

``` r
posNames <- c('Catcher','Infielder','Outfielder','Pitcher')
```

我们正在使用计算机！我们不应该手动输入这些名称，就像我在这一行中所做的那样。实际上，我们已经在我们的一个 R 对象 **rownums** 中拥有了它们；回想一下我们之前的检查：

``` r
> str(rownums)
List of 4
 $ Catcher   : int [1:76] 1 2 3 35 36 66 67 68 101 102 ...
 $ Infielder : int [1:210] 4 5 6 7 8 9 37 38 39 40 ...
 $ Outfielder: int [1:194] 10 11 12 13 14 15 16 43 44 45 ...
 $ Pitcher   : int [1:535] 17 18 19 20 21 22 23 24 25 26 ...
```

R 列表 **rownums** 的元素就是位置的名称！因此，更好的设置 **posNames** 的方法是

``` r
posNames <- names(rownums)
```

> 📘 专业提示

> 再次，读者可能会想，“我怎么能意识到这一点呢？”答案是，随着你在编程中积累更多经验，你将越来越能够像这样提出创造性的见解。耐心！


最后，那些数值结果呢？这些估计的斜率存在相当大的变化，但同样，它们只是估计值。关于在总体水平上是否存在相当大的变化的问题是统计推断的一个问题，将在以后的课程中讨论。


## <a name="cran"> </a> 第25课：R包、CRAN等

R的一个优点是有成千上万的包是由用户开发并贡献到[CRAN代码仓库](https://cran.r-project.org)的。 截至2020年12月，那里有近17000个包。 如果你需要在R中执行一些特殊操作，比如空间数据分析，很可能会在那里找到。 你可以以[CRAN任务视图](https://cran.r-project.org/web/views/)为起点，或者简单地使用谷歌搜索，比如输入搜索词 "CRAN 空间数据"。 其他公开R包的好来源还包括[Bioconductor](https://www.bioconductor.org/)和用户个人的GitHub页面。

下面，我们将介绍一个最受欢迎的用户贡献包，**ggplot2**。 但首先，如何安装和加载包呢？

首先，你需要一个放置包的地方。 用户通常会为他们的包（无论是下载的还是自己编写的）指定一个特殊的文件夹/目录。 我在我的主目录中使用'R'来做这个用途，但如果你没有指定一个文件夹，你的包安装程序会为你选择一个。 只要你保持一致，这并不重要。 我会假设你没有指定一个包文件夹。

要安装，比如说，**ggplot2**，你可以在R提示符下输入：

``` r
> install.packages('ggplot2')
```

或在RStudio中，选择工具 | 安装包...

当你想要使用你安装的包之一时，你需要告诉R加载它，比如在R提示符下输入：

``` r
> library(ggplot2)
```

在RStudio中，点击包按钮，然后选择你想要的包；可能会有一个延迟，因为R正在列出所有你的包。

稍后，你会编写自己的R包。 我们不会在这里涵盖这个内容，但是网络上有很多好的教程。


## <a name="advanced"> </a> 第26课：深入学习前的暂停

到目前为止，你已经对R有了相当扎实的基础。你能够在R中做很多事情。这可能已经满足你的需求了，但即使不是，你也知道足够的知识，在遇到问题时可以在线上提问。

剩下的话题更加深入，课程会比之前的更长，更详细。但是我强烈建议你继续学习，因为它们不仅涵盖了新的主题，还会让你对之前的内容有更深入的理解。

## <a name="gg2first"> </a> 第27课：ggplot2 绘图包

现在，让我们开始学习 **ggplot2**。

**ggplot2** 包是由Hadley Wickham编写的，他后来成为了RStudio的首席科学家。这个包非常复杂，拥有400多个函数，而且相当抽象，但非常强大。在本教程中，我们会在适当的时候涉及到它，但在更容易使用基本R绘图时，我们会继续使用基本R绘图。

现在，在使用 **ggplot2** 之前，让我们先用基本R绘图再做一些准备工作，继续我们对球员体重/年龄的调查。首先，让我们绘制一个体重与年龄的散点图，按职位进行颜色编码。我们可以输入：

``` r
> plot(mlb$Age, mlb$Weight, col = mlb$PosCategory)
```

但为了节省一些输入，让我们使用R的 **with** 函数（顺便改变一下点的大小）：

``` r
> with(mlb, plot(Age, Weight, col = PosCategory, cex = 0.6))
```

通过使用 **with**，我们告诉R在 **mlb** 的上下文中使用 Age、Weight 和 PosCategory。

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/WtAgePosBase.png)

现在我们来看看如何使用 **ggplot2**：

首先，我创建一个基于数据框 **mlb** 的空白图：

``` r
> p <- ggplot(mlb)
```

屏幕上不会显示任何内容。这个包只有在你“打印”出图形时才会显示：

``` r
> p
```

这只会显示一个空白图。 （试试看。）顺便提一句，回想一下，你键入的任何表达式，甚至是 1 + 1，都将被计算并显示在屏幕上。这里的图形（尽管是空的）被打印到了屏幕上。

现在让我们做点有用的事情：

``` r
> p + geom_point(aes(x = Age, y = Weight, col = PosCategory), cex = 0.6)
```

![alt text](https://raw.githubusercontent.com/matloff/fasteR/master/inst/images/WtAgePosGG.png)

这里发生了什么？实际上有很多事情，所以让我们慢慢来。

* 我们拿到了我们现有的（空白的）图，**p**，通过写 '+' 符号，告诉 **ggplot2** 在图 **p** 上添加内容。

* 现在，我们想要添加什么呢？我们是在说，“**ggplot2**，请在图 **p** 中添加 **geom_point** 返回的内容。”

* 注意，**geom_point** 是一个 **ggplot2** 函数。它的任务是生成散点图。

* 关于 **geom_point** 参数的详细信息如下：
  
    * 我们想要绘制体重与身高。我们不需要指定这两个变量来自哪个数据框，因为我们已经说明了图 **p** 是为数据框 **mlb** 准备的。

    * 我们还指定了颜色编码将根据球员的职位来进行，同样来自 **mlb**。

* 当R计算整个表达式 **p + geom_point(aes(x = Age, y = Weight, col = PosCategory), cex = 0.6)** 时，结果将是另一个 **ggplot2** 图形对象。由于我们在 '>' 提示符处键入了该表达式，它随后被打印到屏幕上，如上所示。

* 还有一个谜团留下来了：函数 **aes**（“aesthetic”）做什么？为什么表达式 **cex=0.6** 不是 **aes** 的参数？不幸的是，这些问题没有简单的答案，在我们解释所有内容的罕见例外情况下，我们只能将其留作必须完成的事情。

有一件好事是，我们自动得到了一个图例打印在图的右边，这样我们就知道哪种颜色对应哪种职位。在基本R图形中，我们也可以做到这一点，但需要在 **plot** 中设置一个参数。


## <a name="appfam"> </a> 第28课：你应该使用函数式编程吗？

在本教程的前面部分，我们发现R的 **tapply** 函数非常方便。在这个函数家族中还有其他几个函数，特别是 **apply**、**lapply** 和 **sapply**。此外，还有其他相关的函数，如 **do.call** 和 **Reduce**。在Tidyverse **purrr** 包中还有一些相应的函数。所有这些都属于 *函数式编程*（FP）的范畴。

对许多人来说，FP 旨在作为循环的高级替代方案，而且R社区的一些成员认为这是值得的，甚至是必须的。我个人持有一个更加中庸的观点，但在讨论争议之前，让我们看看FP作为循环替代的工作原理。

举一个简单的例子，假设我们有一个非负整数向量 **x**，并且希望编写代码来对大于9的每个元素进行双倍计数。当然，在这种情况下，我们首先不应该使用循环。我们应该利用R的向量化功能：

``` r
x <- ifelse(x > 9, 2 * x, x)
```

但是为了说明问题，让我们忽略向量化，编写一个循环版本：

``` r
for (i in 1:5) if (x[i] > 9) x[i] <- 2 * x[i]
```

现在，我们如何通过调用R的 **sapply** 函数来替换这个循环呢？后者的调用形式为

``` r
sapply(X, FUN)
```

其中 **X** 是一个R因子，**FUN** 是一个函数。我们在这里假设 **FUN** 返回一个数字，而不是向量或其他R对象。函数的作用是在 **X** 的每个元素上应用 **FUN**，生成一个新的向量。（当然也可以重新分配给旧的向量。）

关键是定义 **FUN**：

``` r
doubleIt <- function(z) if (z > 9) return(2 * z) else return(z)
sapply(x, doubleIt)
```

我们来检查一下：

``` r
> x <- c(5, 12, 13, 8, 88)
> x <- sapply(x, doubleIt)
> x
[1]   5  24  26   8 176
```

或者，我们可以使用所谓的*匿名*函数：

``` r
> x <- c(5, 12, 13, 8, 88)
> x <- sapply(x, function(z) if (z > 9) return(2 * z) else return(z))
> x
[1]   5  24  26   8 176
```

我们不需要单独定义函数，而是直接在 **sapply** 的第二个参数中定义它。

现在让我们考虑一些更复杂的事情。回想一下我们之前的棒球球员例子，我们想要对每个四个球员位置类别分别拟合回归线。我们使用了一个循环，为了方便起见，我在这里复制一下：

``` r
rownums <- split(1:nrow(mlb), mlb$PosCategory)
posNames <- c('Catcher', 'Infielder', 'Outfielder', 'Pitcher')
m <- data.frame()
for (pos in posNames) {
  lmo <- lm(Weight ~ Age, data = mlb[rownums[[pos]], ])
  newrow <- lmo$coefficients
  m <- rbind(m, newrow)
}
```

我们如何在FP中完成这个任务呢？我们已经几次看到了 **tapply** 函数。现在让我们转向 **lapply**（“列表应用”）。其调用形式为

``` r
lapply(VectorOrList, FUN)
```

第一个参数必须是一个向量或列表，第二个参数必须是一个一参数函数的名称。这会在 **VectorOrList** 的每个元素上调用 **FUN**，将返回值放入一个新的列表中。

我们如何在这里使用它呢？好吧，正如其名称所暗示的，**lapply** 是用于操作列表的。我们有吗？是的，**rownums** 就是一个列表！

事实上，我们确实希望对该列表的每个元素执行一些操作：我们想要为该元素中的行拟合一个线性回归模型。因此，自然而然地，我们将以下函数作为 **FUN**：

``` r
zlm <- function(rws) lm(Weight ~ Age, data = mlb[rws, ]) $ coefficients
```

这里 **rws** 是一组行号，例如投手的行号。此函数调用 **lm** 对这些行进行拟合，即在数据 **mlb[rws, ]** 上，然后提取回归系数。

那么代码就是

``` r
> zlm <- function(rws) lm(Weight ~ Age, data = mlb[rws, ]) $ coefficients
> w <- lapply(rownums, zlm)
```

然后对 **lapply** 的调用表示，运行 **zlm** 在我们在 **rownums** 中看到的每组行上，将系数向量放入一个输出列表中。
具体来说：回忆一下 **rownums** 的第一个元素是 **rownums[['catcher']]**。所以，首先 **lapply** 将调用

``` r
zlm(rownums[['Catcher']])
```

这将对捕手数据拟合所需的回归模型。然后 **lapply** 将执行

``` r
zlm(rownums[['Infielder']])
```

等等。四个 **lm** 调用的输出将以一个R列表的形式返回，我们将其分配给了上面的 **w**。我们来检查第一个：

```r
> w[[1]]
(Intercept)         Age 
180.8280290   0.7949252 
```
与我们在上面的数据框/循环方法中的 **m[1,]** 相符。

那么，通过在这里使用 **lapply** 而不是我们之前使用的循环方法，我们实现了什么 -- 如果有的话？当然，**lapply** 版本确实使得代码更加紧凑，只有2行。但我们必须更加努力地思考来提出这个想法。此外，打印输出也不那么紧凑：

```r
> w
$Catcher
(Intercept)         Age 
180.8280290   0.7949252 

$Infielder
(Intercept)         Age 
170.2465739   0.8589593 

$Outfielder
(Intercept)         Age 
176.2884016   0.7883343 

$Pitcher
(Intercept)         Age 
185.5993689   0.6543904 
```

（实际上，我们可以在这里使用 **sapply** 替代 **lapply**，输出更加美观。）

那么，初学者应该使用FP吗？实际上，即使是我，拥有几十年的编码经验，也采取了一个中庸的方法。对于基于循环（LB）的代码与 FP，判断标准应该是问自己以下问题：

* 在这种情况下，使用FP代码是否比使用LB更容易编写？
* 在这种情况下，使用FP代码是否比使用LB更容易调试？
* 在这种情况下，使用FP代码是否更容易阅读 -- 无论是其他人还是自己6个月后 -- 与使用LB相比？

对于我们在本教程中使用 **tapply** 的代码，我认为上面的问题的答案肯定是肯定的。但对于上面的 **lapply** 示例，我会说答案是否定的 -- *特别是对于初学者*，但即使对于我自己也是如此。

初学者正在学习函数。FP 的定义是基于编写函数，因此使得 FP 更加抽象和困难。我当然不同意某些人的教条观点，认为从不应该编写循环。

我的建议是根据具体情况进行判断。

现在，让我们转向 **apply** 家族中的另一个核心函数。毫不奇怪，它的名称是 **apply**！它通常用于 **matrix** 对象（类似于数据框，但内容都是相同类型的，例如都是数值），可以用于行或列，但也可以用于数据框。

调用形式为

```r
apply(d, rc, g)
```

在这里，R将会将函数 **g** 应用于数据 **d** 的每一行（**rc** = 1）或列（**rc** = 2）。如果函数 **g** 返回一个数字，则 **apply** 将返回一个向量。

让我们找到 **pima** 数据中变量的最大值：

```r
> apply(pima, 2, max)
 pregnant   glucose diastolic   triceps   insulin       bmi  diabetes
age 
    17.00    199.00    122.00     99.00    846.00     67.10      2.42
81.00 
     test 
     1.00 
```

请注意，要使用 **apply** 家族，您可以使用内置的 R 函数，例如这里的 **max**，或者您自己编写的函数，例如上面的 **zlm**。

R 的 **apply** 家族还包括其他函数。它们非常有用，但不要仅仅为了避免编写循环而使用它们。更紧凑的代码可能不一定更容易理解。

## <a name="txt"> </a> 第29课：简单文本处理，I

如今，在数据科学领域，文本处理非常重要，例如在自然语言处理应用中。在本课程中，我们将进行一个简单但实用的示例，以便说明基础R中的一些关键函数。（R 有许多用于高级文本处理的包，例如 **tm**。）

我们的示例将涵盖读取文本文件，并编制一个词频统计，即计算每个单词出现的次数。这种任务是许多文本分类算法的核心。

该文件是
[这里](https://raw.githubusercontent.com/matloff/fasteR/master/data/aboutR.txt)。
它基本上是[R项目主页](https://www.r-project.org/)的 About 部分。以下是前几行：

```
What is R?

Introduction to R

   R is a language and environment for statistical computing and graphics.
```

现在，我们如何读取文件呢？例如，**read.table** 不起作用，因为它期望每行有相同数量的非空字段。正如您上面所看到的，我们的文件每行具有可变数量的字段。

相反，我们通过一个名为 **readLines** 的函数读取文件的行：

```r
> abt <- readLines('https://raw.githubusercontent.com/matloff/fasteR/master/data/aboutR.txt')
```

那么，现在 **abt** 中究竟是什么？让我们转向我们通常的检查工具 **str**。

```r
> str(abt)
 chr [1:70] "" "What is R?" "" "Introduction to R" "" ...
```

所以，**abt** 是一个由70个元素组成的字符向量。这个向量的每个元素是文件中的一行：

```
> head(abt)
[1] ""                                                                          
[2] "What is R?"                                                                
[3] ""                                                                          
[4] "Introduction to R"                                                         
[5] ""                                                                          
[6] "   R is a language and environment
```

文件中的第一行为空，因此 **abt[1]** 为空字符串（""），以此类推。

请记住，我们在这里的目标是将文件中的各种单词制成表格。我们不会对每一行进行制表，所以让我们将 **abt** 变成一个长长的行。

主要的 R 函数用于连接字符串是 **paste**。例如，

``` r
> paste('abc','987')
[1] "abc 987"
```

它也可以应用于向量的逐个元素，但是正如所述，我们希望创建一个长向量。**collapse** 参数为我们完成了这项任务：

``` r
abt1 <- paste(abt, collapse=' ')
```

这表示：“将 **abt** 中的所有 70 个字符串合并为一个大字符串，原始字符串的每个元素之间用单个空格分隔。” 因此，它将 **abt** 的元素连接成一个长字符串 **abt1**，其中 **abt** 的连续元素之间用一个空格分隔（除了原始字符串中存在的空格）。

``` r
> str(abt1)
 chr " What is R?  Introduction to R     R is a language and environment for statistical computing and graphics.    I"| __truncated__
```

因此，**abt1** 现在是一个单一的字符字符串。我们可以使用 **substr** 函数检查它的部分内容，例如，

``` r
> substr(abt1,288,336)
[1] "nd colleagues. R can be considered as a    differ"
```

告诉我们 **abt1** 中第 288 到第 336 个字符。**abt1** 中总共有多少个字符？

``` r
> nchar(abt1)
[1] 3461
```

现在，我们需要将 **abt1** 拆分为单个单词。我们可以使用 **strsplit** 来完成：

``` r
> y <- strsplit(abt1, ' ')
> str(y)
List of 1
```

第二个参数 ' ' 表示我们希望使用空格字符作为拆分定界符。在其他情况下，我们可能希望使用逗号作为拆分定界符，或者其他字符。

现在让我们来看看 **y**。请记住，该对象是一个 R 列表，我们可以使用双括号检查 **y** 的第一个元素（正如我们之前看到的，**y** 是一个 "1 个列表"）。

``` r
> str(y[[1]])
 chr [1:722] "" "What" "is" "R?" "" "Introduction" "to" "R" "" "" "" "" "R" ..
```

因此，**y[[1]]** 是一个长度为 722 的字符向量。原始文本中的每个单词都有一个元素，尽管一些 "单词" 实际上是空的。我们在这里看到，文本中的第一个单词 **y[[1]][1]** 是空的，第二个单词 **y[[1]][2]** 是 'What'，第三个是 'is'，依此类推。

> 📘 **始终牢记**
>  
> 当涉及到 R（或任何其他语言）的这个级别时，仔细注意所有 R 对象的类别和大小至关重要。
> 
> 在这里，我们有：
>
> * **abt** 是长度为 70 的字符向量（文本中有 70 行）
> * **abt1** 是长度为 1 的字符向量（整个文本为 1 个长字符串）
> * **y** 是长度为 1 的 R 列表
> * **y[[1]]** 是长度为 722 的字符向量（文本中有 722 个单词）
> * **y[[1]][1]**、**y[[1]][2]** 等是字符串（第一个单词、第二个单词...）
>
> 对象类型之间的微妙差异可能在行动中产生重大差异。
>
> *处理这些并不是什么难事，只是需要耐心。* 作为读者，您现在应该花一些时间确保您理解了上述各种变量的情况。

现在，为什么 R 列表 **y** 的长度仅为 1？答案是因为只有一个字符串输入到了 **strsplit** 中。回想一下我们做了什么：

``` r
> y <- strsplit(abt1, ' ')
```

如果 **abt1** 由 5 个字符串而不是只有 1 个字符串组成，那么 **y** 就会成为一个包含 5 个元素的 R 列表。

在原始输入的某些地方，我们有几个连续的空白。当有多个连续的空白时，**strsplit** 函数将多余的空白视为 "单词"。（这对于 Python 程序员来说可能有些令人惊讶。）

那么，如何去掉空白的 "单词"？

``` r
> y1 <- y[[1]]  # 更易读，更简洁
> allWords <- y1[y1 != '']  # '!=' 表示 "不等于"
> allWords
  [1] "What"                      "is"
  [3] "R?"                        "Introduction"
  [5] "to"                        "R"
...
```

表达式

``` r
y1[y1 != '']
```

可能看起来有些神秘，但实际上它的工作方式与我们之前在提取向量、数据框等的子集中看到的工作方式相同：

1. 正如注释中所指出的，**!=** 表示不等于，因此 **!= ''** 表示 "不是空单词"。（警告：这将在下面导致一些双重否定。再次强调，只需耐心等待（这是任何程序员的至高无上的品质）。

2. 请记住，**y1** 的每个元素都是一个 "单词"，共有 722 个单词。我们之前看到的第一个单词是 ''，即空字符串，第二个是 "What"，依此类推。表达式 **y1 != ''** 产生了 722 个 TRUE 和 FALSE，第一个是 FALSE（不，第一个单词不是非空的），第二个是 TRUE（是的，第二个单词是非空的），依此类推。

3. 正如我们之前看到的，对取值为 TRUE 和 FALSE 的索引进行评估将保留对应于 TRUE 的向量元素。换句话说，表达式 **y1[y1 != '']** 包含了非空单词。

因此，**allWords** 正是我们所需要的——将原始文件内容拆分为单个单词，没有空单词。

另外还有一些要点：

* '!' 在 R 中表示 "非"，例如，

``` r
> 3 < 8
[1] TRUE
> !(3 < 8)
[1] FALSE
```

* '#' 后面的内容是 `注释`，是程序员插入的注释，用于解释代码，提高清晰度和未来可维护性，以帮助自己和/或其他阅读代码的人。（在许多情况下，注释是为了使您——读者受益。）

我们将在下一课继续这个示例，但首先，进行 **Your Turn** 会话。

> ❄️  轮到你了
>
> 编写代码确定 **abt** 中哪一行是最长的，即字符数最多的。

## <a name="txt1"> </a> 第 30 课：简单文本处理，II

现在，让我们完成我们的目标，生成原始文本的单词计数，即文本中出现的单词以及每个单词出现的次数是多少？

像往常一样，检查结果是必不可少的，比如前 25 个元素：

``` r
> head(allWords,25)
 [1] "What"         "is"           "R?"          
 [4] "Introduction" "to"           "R"           
 [7] "R"            "is"           "a"           
[10] "language"     "and"          "environment" 
[13] "for"          "statistical"  "computing"   
[16] "and"          "graphics."    "It"          
[19] "is"           "a"            "GNU"         
[22] "project"      "which"        "is"          
[25] "similar"     
```

很好，所有单词似乎都在那里，"" 也不在那里，正如所期望的那样。但是如何获得单词计数呢？嗯，这是我们的老朋友 **tapply**！

``` r
> q <- tapply(allWords, allWords, length)
> head(q,25)
            ;            …) “environment”      (easily)     (formerly 
            1             1             1             1             1 
   (including       (linear             *             ©             a 
            1             1             5             1            13 
        about     accretion     activity.           add    additional 
            3             1             1             1             1 
     Advanced   algorithmic        allows            an      analysis 
            1             1             1             5             2 
    analysis,           and           are        around       arrays, 
            2            27             4             1             1 
```

我们已经去掉了空白单词，但是这里的报告仍然有些粗糙，例如将 ';' 视为 "单词"。但总体上，它正在做我们想要的事情，例如显示原始文本中单词 "analysis" 出现了 2 次。

现在，为什么这里调用 **tapply** 呢？实际上，这与我们之前看到的 **tapply** 是相同的模式，第三个参数是 **length** 函数。可能看起来有点奇怪的是，前两个参数是相同的，但这是有道理的：

1. 第一个参数表示我们要将 **allWords** 向量拆分成堆。

2. 第二个参数表示我们希望 *堆* 的 *定义* 也基于 **allWords**。换句话说，我们希望每个不同的单词都有一个单独的堆。

3. 我们非正式地称之为 "堆" 的每个实体都是一个 R 向量：

``` r
    > str(allWords)
   chr [1:515] "What" "is" "R?" "Introduction" "to" "R" "R" "is" "a" ...
```

对每个向量应用 **length** 函数给出了每个堆中的计数，正是我们所需要的。

> 📘 专业提示
>
> 在编码中，某些模式确实经常出现，例如我们在这里看到的 **tapply(x, x, length)** 技巧。事实上，甚至有一些标题中带有 "设计模式" 的编码书籍。当您经常看到相同的模式时，请注意，因为它可能会派上用场。

我们还没有完全完成。例如，我们存在标点符号问题，其中句点、逗号等被视为单词的一部分，比如在上面看到的 **allWords[17]** 中的句点 'graphics.'。我们也可能需要将大写字母改为小写，这样 'What' 和 'what' 不会被视为两个不同的单词。

对于主要的用法，我们应考虑使用文本处理中的一种高级 R 包。例如，**tm** 包具有一个 **removePunctuation** 函数。但让我们看看如何使用基础知识来完成这个任务。

我们将使用 R 的 **gsub** 函数。我们将使用的调用形式如下：

``` r
gsub(string_to_change, replacement, input_vector, fixed=TRUE)
```

例如，

``` r
> a <- c('abc','de.')
> gsub('.','',a,fixed=TRUE)  # 将 '.' 替换为空字符串
[1] "abc" "de" 
```

（**fixed** 参数很复杂，并出现在所有 R 字符串操作包中。这是你现在应该使用的东西，并且在你熟练掌握 R 后可以深入研究。）

因此，要删除 **allWords** 中的所有句点，我们可以这样做：

``` r
> awNoPers <- gsub('.','',allWords,fixed=TRUE) 
> awNoPers[17]  # 检查是否生效
[1] "graphics"
```

我们可以继续以这种方式微调输出。

## <a name="linreg2"> </a> 第 31 课：线性回归分析，II

继续我们对使用 R 进行线性回归分析的探讨，让我们看看著名的[自行车共享数据](ttps://archive.ics.uci.edu/ml/datasets/bike+sharing+dataset)。（参见后一网站以获取文档；例如，温度已经被缩放，而不是用度数来测量。）它在一个 **.zip** 文件中，所以需要一些额外的预处理：

``` r
# 从网络获取，并将下载的数据存储到文件 'bike.sip'
> download.file('https://archive.ics.uci.edu/ml/machine-learning-databases/00275/Bike-Sharing-Dataset.zip','bike.zip')
> unzip('bike.zip')  # 出来的文件是 'day.csv' 和 'hour.csv'
> day <- read.csv('day.csv',header=TRUE)
> head(day)  # 总是先四处看看！
  instant     dteday season yr mnth holiday weekday workingday weathersit
1       1 2011-01-01      1  0    1       0       6          0          2
2       2 2011-01-02      1  0    1       0       0          0          2
3       3 2011-01-03      1  0    1       0       1          1          1
4       4 2011-01-04      1  0    1       0       2          1          1
5       5 2011-01-05      1  0    1       0       3          1          1
6       6 2011-01-06      1  0    1       0       4          1          1
      temp    atemp      hum windspeed casual registered  cnt
1 0.344167 0.363625 0.805833 0.1604460    331        654  985
2 0.363478 0.353739 0.696087 0.2485390    131        670  801
3 0.196364 0.189405 0.437273 0.2483090    120       1229 1349
4 0.200000 0.212122 0.590435 0.1602960    108       1454 1562
5 0.226957 0.229270 0.436957 0.1869000     82       1518 1600
6 0.204348 0.233209 0.518261 0.0895652     88       1518 1606
```

顺便提一下，天气变量已经被重新缩放到区间 [0,1]。例如，0.28 的值意味着该变量的值在最小值和最大值之间的 28%。

这里的一个新概念是*指示器*变量，更不正式地称为*虚拟变量*。这些是只取值 0 和 1 的变量，其中 1 "指示" 某个特征的存在。例如，**holiday** 变量要么是 1 要么是 0，取决于那一天是否是假日（这可能会影响到当天的自行车需求）。

管理这个自行车共享服务的人可能希望预测未来的自行车需求，比如下一天，以帮助他们的规划。例如，让我们尝试根据一些天气变量和虚拟变量 **workingday** 来预测休闲骑行者的数量。

``` r
> day1 <- day[,c(8,10,12:14)]
> head(day1)
  workingday     temp      hum windspeed casual
1          0 0.344167 0.805833 0.1604460    331
2          0 0.363478 0.696087 0.2485390    131
3          1 0.196364 0.437273 0.2483090    120
4          1 0.200000 0.590435 0.1602960    108
5          1 0.226957 0.436957 0.1869000     82
6          1 0.204348 0.518261 0.0895652     88
> lmout <- lm(casual ~ .,data=day1)
> lmout
...
Coefficients:
(Intercept)   workingday         temp          hum    windspeed  
     1063.6       -806.6       2149.5       -812.7      -1145.3  
 
```

表达式 "casual ~ ." 的意思是，“对数据集中的所有其他变量进行 **casual** 的回归。

这些数字是有意义的。**workingday** 的负系数表示，其他条件相同，工作日通常会有较少的休闲骑行者。

顺便说一下，我们可能应该预期在非常寒冷或非常炎热的天气里骑行者较少，所以我们可能希望给模型添加一个二次项，比如通过执行

``` r
day1$temp2 <- temp^2  # 尖角符号表示指数运算，即这里是 2 次幂
```

这将在 **day1** 中添加指定的列。但我们现在不会追求这个。

R 的一个非常重要的特性是*通用函数*。这些函数对不同类别的对象扮演不同的角色。**plot** 函数就是一个例子。

在 R 提示符下输入 "plot(lmout)"。你将会看到几个描述拟合回归模型的图形。发生的事情是，函数 **plot** 只是一个占位符。当我们输入 "plot(lmout)" 时，R 会说，“嗯，**lmout** 是什么类型的对象呢？哦，它是 **'lm'** 类型。所以我要将此调用传递（*dispatch*）给一个涉及该类别的特殊绘图函数 **plot.lm**。” 这与我们之前对**plot**的调用形成对比，那些调用是在向量上调用的；那些调用被传递给 **plot.default**。

另一个通用函数是 **summary**：

``` r
> summary(Nile)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  456.0   798.5   893.5   919.4  1032.5  1370.0 
> summary(lmout)
...
Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)  1063.55     101.37  10.492  < 2e-16 ***
workingday   -806.63      33.41 -24.143  < 2e-16 ***
temp         2149.52      86.32  24.901  < 2e-16 ***
hum          -812.74     112.98  -7.194 1.57e-12 ***
windspeed   -1145.31     208.55  -5.492 5.51e-08 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
...
```

在第一个情况中，对向量调用的 **summary** 被传递到 **summary.default**，而在第二个情况中，转移是到 **summary.lm**。在这两种情况下，R 开发团队中编写这些函数的人决定了应该自动打印出哪些摘要信息。

再次强调，本教程的目的是介绍 R，而不是统计学。感兴趣的读者应参考统计学书籍，了解 *p 值* 和 *置信区间*。前者显示在上述摘要的最后一列中。例如，湿度的总体系数的大约 95% 的置信区间为 -812.74 加减 1.96 倍的 *标准误差*，即 112.98。请注意，长期以来，p 值一直被认为是糟糕的方法论；参见 [ASA 声明](https://amstat.tandfonline.com/doi/full/10.1080/00031305.2016.1154108)。

另一个重要的通用函数是 **predict**。假设我们想要预测在 **temp**、**hum** 和 **windspeed** 分别为 0.26、0.55 和 0.18 的工作日中的 **casual**。

``` r
> newCase <- data.frame(workingday=1, temp=0.26, hum=0.55, windspeed=0.18)
> predict(lmout,newCase)
       1 
162.6296 
```

**predict** 函数，这里是 **predict.lm**，假定要预测的新案例被提供为一个数据框，其列名与原始数据相同。

## <a name="dates"> </a> 第32课：使用 R 日期类

在自行车共享数据中，日期被包括在 **day$dteday** 中。正如我们注意到的，其中一些是假期，在 **holiday** 列中指示。让我们看看有多少个假期：

``` r
> hds <- day$dteday[day$holiday == 1]
> hds
 [1] 2011-01-17 2011-02-21 2011-04-15 2011-05-30 2011-07-04 2011-09-05
 [7] 2011-10-10 2011-11-11 2011-11-24 2011-12-26 2012-01-02 2012-01-16
[13] 2012-02-20 2012-04-16 2012-05-28 2012-07-04 2012-09-03 2012-10-08
[19] 2012-11-12 2012-11-22 2012-12-25
```

再次回顾以上代码的工作方式。表达式 "[day$holiday == 1]" 产生了一堆 TRUE 和 FALSE。将它们作为索引用于向量 **day$dteday**，就会得到确切的假期日期。

我们在上面看到，在数据时间段内有 21 个假期。但我们可以做得更多。首先，**hds** 是什么类型的对象？

``` r
> class(hds)
[1] "factor"
```

好的，但 R 有一个专门的日期数据类，不出所料被称为 **'Date'**。让我们转换为该类：

``` r
> hd <- as.Date(hds)
> class(hd)
[1] "Date"
> hd
 [1] "2011-01-17" "2011-02-21" "2011-04-15" "2011-05-30" "2011-07-04"
 [6] "2011-09-05" "2011-10-10" "2011-11-11" "2011-11-24" "2011-12-26"
[11] "2012-01-02" "2012-01-16" "2012-02-20" "2012-04-16" "2012-05-28"
[16] "2012-07-04" "2012-09-03" "2012-10-08" "2012-11-12" "2012-11-22"
[21] "2012-12-25"
```

虽然它打印出来的方式与以前一样，但现在有了额外的属性，而且更好的是，它是 POSIX 形式的：

``` r
> hp <- as.POSIXlt(hd)
> hp
 [1] "2011-01-17 UTC" "2011-02-21 UTC" "2011-04-15 UTC" "2011-05-30 UTC"
 [5] "2011-07-04 UTC" "2011-09-05 UTC" "2011-10-10 UTC" "2011-11-11 UTC"
 [9] "2011-11-24 UTC" "2011-12-26 UTC" "2012-01-02 UTC" "2012-01-16 UTC"
[13] "2012-02-20 UTC" "2012-04-16 UTC" "2012-05-28 UTC" "2012-07-04 UTC"
[17] "2012-09-03 UTC" "2012-10-08 UTC" "2012-11-12 UTC" "2012-11-22 UTC"
[21] "2012-12-25 UTC"
> hp[16]$wday  # 2012 年 7 月 4 日是星期几？
[1] 3
# 啊，星期三（代码 3）
```

（UTC 部分是一天中的时间，我们没有提供。）

R 日期可以进行许多操作。以上只是一个小样本。

## <a name="style"> </a> 第33课：有关 R 编码风格和策略的提示

编程是一种创造性活动，因此不同的程序员会有不同的编码风格。有些人感觉非常强烈，以至于会发布自己特定的风格指南，比如 R 社区在 Google 的[这个](https://google.github.io/styleguide/Rguide.xml)。我的风格指南在[这里](https://github.com/matloff/R-Style-Guide)。

毋庸置疑，风格是个人品味的问题。但是：

**对于任何你打算再次使用的代码来说，风格都是重要的，原因有两点：**

1. 你会很快忘记自己的代码是如何工作的。
2. 如果你与他人分享你的代码，你需要让他们清楚地了解它的工作原理。

**同样重要的是策略，即你处理编码项目的方式。**

没有编写代码的魔法公式。正如之前提到的，我不能*教*你如何编写代码。我只能向你展示各种组成部分是如何工作的——循环、变量、函数、if/else 等等——然后你必须创造性地将它们组合起来，编写出实现目标的代码。这就像解决一个大谜题，就像许多大谜题一样，你可能需要花一段时间思考问题，一点一点地获取见解，直到最终完成。然而，就像编码风格一样，我们都同意存在一些策略。

因此，尽管个体差异很大，但有一些共同的方面是每个人都同意的，我们将在这节课中讨论这些方面。

**注释你的代码：**

在任何计算机科学学生的编程课程中，这都是绝对重要的。如果一个学生提交的编程作业几乎没有或没有注释，那么他将得到不及格分数。如果注释对于计算机科学专业的学生来说是需要的，他们可能是强大的程序员，那么对于不是专业程序员的 R 用户来说，注释就更加重要了。

一所顶尖大学计算机科学系的[风格指南](https://www.cs.utah.edu/~germain/PPS/Topics/commenting.html)表达得很好：

> 注释是指在计算机程序中放置人类可读描述，详细说明代码正在做什么。正确使用注释可以使代码维护变得更容易，同时帮助更快地发现错误。此外，在编写其他人将使用的函数时，注释非常重要。请记住，良好的文档代码与正确工作的代码一样重要。

（在该文档的后面部分还有关于注释的具体提示。）

*不要以为你的代码可以自我说明；它并不能！典型的注释可能如下所示：*

``` r
w <- f(w)
# 在这一点上，数据框 w 将由年龄在 65 岁以上且是房主的原始行组成
```

*在每个源文件的顶部，插入注释，给读者一个内容概述。*

这通常包括每个主要函数的作用概述，函数如何相互作用，主要数据结构是什么，等等。

我强烈建议在编写代码之前（当然，随着你编写代码而修改）在文件的顶部写下这些注释。这将在编码过程中帮助你集中注意力。

**缩进你的代码：**

``` r
if (x < y) {
   x <- y^2
   z <- x + y
}
```

比起

``` r
if (x < y) {
x <- y^2
z <- x + y
}
```

要容易得多。

**以自顶向下的方式编写你的代码：**

如果你有一个函数 **f**，它超过了，比如，十几行长，将它的代码分解为对更小的函数调用，比如 **g** 和 **h**。然后 **f** 将由这些调用组成，再加上一些处理返回值等的 "粘合" 行。当然，如何分解问题是个人品味的问题，但关键是这使得你的代码更容易*阅读*（由其他人或者稍后的你自己），更重要的是，更容易*编写*。像这样分解代码使其读起来像一个大纲。

**不要忽视“边界情况”：**

计算机科学家谈论“边界情况”，指的是在特殊情况下，即使代码通常是正确的，也可能失败的情况。

例如，考虑这段代码：

``` r
> i <- 5
> 1:i
[1] 1 2 3 4 5
```

但是当 **i = 0** 的特殊情况呢？

``` r
> i <- 0
> 1:i
[1] 1 0
```

这可能不是你想要的。你可能应该插入一个检查，比如

``` r
if (i >= 1) i:5
```

也许还应该编写代码来处理错误情况。这取决于具体情况，但主要的是要意识到可能存在的边界情况。

**使用调试工具：**

稍后的课程中会更详细地讨论这一点！


## 第34课: 逻辑模型

在我们之前的回归分析示例中，我们预测了一个连续变量，比如人的体重。但如果我们想要预测一个*二元*变量，即记录两个结果中的哪一个发生了呢？

考虑之前示例中的皮马数据集。假设我们要预测某人是否有糖尿病，或者以后会发展出糖尿病。这在数据集的**test**列中编码，1表示患有该疾病，0表示没有。

举个简单的例子，假设我们试图从变量**bmi**和**age**来预测**test**。线性模型将会是：

平均测试 = &beta;<sub>0</sub> + &beta;<sub>1</sub> bmi + &beta;<sub>2</sub> age

请记住，**test**取值为1和0。当我们对一堆1和0取平均值时会发生什么？答案是我们得到1的比例。例如，数字1、0、1、1的平均值为3/4，这恰好是该数据中1的比例。

在统计学术语中，上述方程表达了1的概率 -- 即患有糖尿病的概率 -- 与体重指数和年龄的关系。

这是一个不错的模型，但一个令人不安的地方是右边的结果可能小于0或大于1，这对于概率来说是不可能的。为了解决这个问题，我们可以使用*逻辑*模型，如下所示。

定义逻辑函数为：

l(t) = 1 / (1 + e<sup>-t</sup>)

然后我们修改上述方程为

糖尿病的概率 = l(&beta;<sub>0</sub> + &beta;<sub>1</sub> bmi + &beta;<sub>2</sub> age)

与以前一样，统计细节超出了本R教程的范围，但是下面是如何使用R来估计系数&beta;<sub>i</sub>的方法：

```r
> glout <- glm(test ~ bmi + age, data=pima, family=binomial)
> summary(glout)
...
Coefficients:
            Estimate Std. Error z value Pr(>|z|)    
(Intercept) -5.40378    0.51530 -10.487  < 2e-16 ***
bmi          0.09825    0.01248   7.874 3.45e-15 ***
age          0.04561    0.00694   6.571 4.98e-11 ***
...
```

让我们稍微探讨一下这些估计的&beta;<sub>i</sub>。考虑一下大约平均BMI的女性，比如32岁，并将30岁的人与40岁的人进行比较。

```r
> l <- function(t) 1 / (1 + exp(-t))
> l(-5.40378 + 32*0.09825 + 30*0.04561)
[1] 0.2908045
> l(-5.40378 + 32*0.09825 + 40*0.04561)
[1] 0.3928424
```

因此，这10年期间糖尿病的风险在这个人群和BMI水平上显着增加。

## 第35课: 文件和文件夹/目录

注意：在Unix系列系统（如Linux）中，Windows术语*文件夹*被称为*目录*。您在Mac讨论中也经常会看到这一点。（Mac OS是Unix系列系统。）我们通常在这里使用术语*目录*，因为R就是这样使用的。

在为我的**regtools**包组装数据集时，我需要收集几门课程的记录。我从一个包含每门课程子目录的目录开始。依次，每个子目录中有一个名为**Results**的文件。作为中间步骤，我想找到所有这些文件，将每个文件的文本放入一个R列表**gFiles**中。只保留每个文件的特定列。（这里讨论的是稍微调整过的版本。）

我使用的主要R函数有：

* **list.dirs:** 返回一个字符向量，其中包含当前目录中所有子目录的名称。

* **dir:** 返回一个字符向量，其中包含当前目录中所有文件的名称。

* **%in%:** 确定指定对象是否是指定向量中的元素。

* **setwd:** 更改到指定的目录。

以下是代码：

```r
getData <- function() {

   currDir <- getwd()  # 留下一串面包屑

   dirs <- list.dirs(recursive=FALSE)
   numCourseOfferings <- 0
   # 创建一个空的R列表，我们将在其中存储我们的课程记录
   resultsFiles <- list()
   for (d in dirs) {
      setwd(d)  # 进入d目录
      # 检查是否存在一个Results文件
      fls <- dir()
      if (!('Results' %in% fls)) {  # 没有，跳过此目录
         setwd(currDir)
         next
      }
      # 啊，这里有这样一个文件；增加我们的计数
      numCourseOfferings <- numCourseOfferings + 1
      # 打开它
      resultsLines <- readLines('Results')
      # 删除注释行；查看每行的第一个字符
      resultsLines <- delComments(resultsLines)
      resultsFiles[[numCourseOfferings]] <- extractCols(resultsLines)
      setwd(currDir)
   }
   resultsFiles  # 返回所有的成绩记录
}
```

在我们深入细节之前，注意以下几点：


* 代码是以自顶向下的方式编写的。大部分**getData**的工作被分派给其他函数（未显示的代码），即**delComments**和**extractCols**。

* 有很多注释！

现在，考虑下面的代码行

```r
   dirs <- list.dirs(recursive=FALSE)
```

如上所述，**list.dirs**将确定当前目录中的所有子目录。但是子目录的子目录呢？以及子目录的子目录的子目录呢？依此类推？将**recursive**设置为FALSE意味着我们只想要第一级子目录。

所以，代码行

```r
   for (d in dirs) {
```

将逐个处理每个（第一级）目录。

当我们进入其中一个子目录时，代码行

```r
      fls <- dir()
```

将确定其中的所有文件，并将结果存储为字符向量**fls**。

然后，正如注释所述，下面的代码行

```r
      if (!('Results' %in% fls)) {  # 没有，跳过此目录
         setwd(currDir)
         next
      }
```

将在这个子目录中没有**Results**文件的情况下跳过此子目录。R关键字**next**表示“转到循环的下一个迭代”，这里意味着处理下一个子目录。注意，为了准备这个，我们需要回到原始目录：

```r
         setwd(currDir)
```

另一方面，如果这个子目录*包含*名为**Results**的文件，剩下的代码将增加这样的文件的计数，读取找到的文件，并将其内容分配为我们的**resultsFiles**列表的新元素。

## 第36课: R的'while'循环

我们在之前的课程中已经见过R的**for**循环，但还有另一种循环，**while**。它会一直迭代直到满足某个指定条件。与**for**循环不同，我们不知道需要多少次迭代。

作为例子，考虑r的内置数据集**AirPassengers**，它包含了从1949年1月开始的月度数据中的几千名空乘旅客数量。和往常一样，让我们先看一下：

```r
> airpass <- AirPassengers  # 下面输入较少
> str(airpass)
 时间序列 [1:144] 从1949年到1961年：112 118 132 129 121 135 148 148 136 119 ...
```

假设我们想知道累计旅客人数首次超过1000万的时间。一种简单的方法是使用R的**cumsum**（“累计求和”）函数：


``` r
> cumsum(airpass)
  [1]   112   230   362   491   612   747   895  1043  1179  1298  1402  1520
 [13]  1635  1761  1902  2037  2162  2311  2481  2651  2809  2942  3056  3196
 [25]  3341  3491  3669  3832  4004  4182  4381  4580  4764  4926  5072  5238
 [37]  5409  5589  5782  5963  6146  6364  6594  6836  7045  7236  7408  7602
 [49]  7798  7994  8230  8465  8694  8937  9201  9473  9710  9921 10101 10302
 [61] 10506 10694 10929 11156 11390 11654 11956 12249 12508 12737 12940 13169
 [73] 13411 13644 13911 14180 14450 14765 15129 15476 15788 16062 16299 16577
 [85] 16861 17138 17455 17768 18086 18460 18873 19278 19633 19939 20210 20516
 [97] 20831 21132 21488 21836 22191 22613 23078 23545 23949 24296 24601 24937
[109] 25277 25595 25957 26305 26668 27103 27594 28099 28503 28862 29172 29509
[121] 29869 30211 30617 31013 31433 31905 32453 33012 33475 33882 34244 34649
[133] 35066 35457 35876 36337 36809 37344 37966 38572 39080 39541 39931 40363
```

我们看到这发生在第60个月。但尽管这种方法会很方便，但也会很浪费：我们正在计算*所有*累积和，尽管我们并不需要它们全部。在一个非常长的向量中，这可能会很慢。这里是一个更节约的方法：

```r
tot <- 0
i <- 1
while (i <= length(airpass) && tot < 10000) {  ## && 表示 'and'
    i <- i + 1
    tot <- tot + airpass[i]
}
i  # 输出 60
```

因此，**while**循环会一直迭代，直到我们得到所需的累积总和。

关键点在于：

* **<=** 运算符表示“小于或等于”。还有**>=**表示“大于或等于”。

* **&&** 运算符代表“且”。它与**&**运算符略有不同，后者涉及向量操作数。

* 在'while'内的条件表示：（a）我们还没有到达**airpass**向量的末尾，且（b）我们的总和仍然小于10000。

* 注意条件 **i <= length(airpass)** 的必要性。可能**tot**永远不会超过10000（在这里不成立，但我们无法*事先*知道），因此我们需要这个条件，以防止循环永远迭代！

不过，还有更多。**cumsum**函数是向量化的，因此使用它，尽管看起来有些浪费，实际上可能比循环更快。

## <a name="forMore"> </a> 进一步学习

这些是我经常参考的书籍和其他资源（是的，我确实会查阅我自己的书籍；不可能把所有东西都记在脑子里 :-) ），以及我推荐的其他资源。


**Nonprogramming Coverage of R**

* Andrie de Vries and Joris Meys, *R For Dummies* (second edition), For
  Dummies

* Jaren Lander,  *R for Everyone: Advanced Analytics and Graphics*
  (second ed.), Addison-Wesley

**R Programming and Language**

* John Chambers, *Software for Data Analysis: Programming with R*, Springer

* Dirk Eddelbuettel, *Seamless R and C++ Integration with Rcpp*,
  Springer

* Colin Gillespie and Robin Lovelace, *Efficient R Programming: A
  Practical Guide to Smarter Programming*

* Norm Matloff, *The Art of R Programming*, NSP

* Norm Matloff, *Parallel Computation for Data Science*, CRC

* Hadley Wickham, *Advanced R* (second edition), CRC

**Data Science with R**

* Nina Zumel and John Mount, *Practical Data Science with R*, Manning
  (2nd ed.)

* Hadley Wickham and Garrett Grolemund, *R for Data Science: Import,
Tidy, Transform, Visualize, and Model Data*, O'Reilly

**Graphics in R**

* Winston Chang, *R Graphics Cookbook: Practical Recipes for Visualizing Data*, O'Reilly

* Paul Murrell, *R Graphics* (third edition), CRC

* Deepayan Sarkar, *Lattice: Multivariate Data Visualization with R*,
Springer

* Hadley Wickham, *ggplot2: Elegant Graphics for Data Analysis*, Springer

**Regression Analysis and Machine Learning, Using R**

* Francis Chollet and JJ Allaire, *Deep Learning in R*, Manning

* Julian Faraway, *Linear Models with R*, CRC

* Julian Faraway, *Extending the Linear Model with R*, CRC

* John Fox and Sanford Weisberg, *An R Companion to Applied Regression*,
SAGE

* Frank Harrell, *Regression Modeling Strategies: With Applications to
Linear Models, Logistic and Ordinal Regression, and Survival Analysis*,
Springer 

*  Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani,
*Introduction to Statistical Learning: with Applications in R*, 
Springer, 2nd ed. 

* Max Kuhn, *Applied Predictive Modeling*, Springer

* Max Kuhn and Kjell Johnson, Feature Engineering and Selection: *A
Practical Approach for Predictive Models*, CRC

* Norm Matloff, *Statistical Regression and Classification: from Linear
Models to Machine Learning*, CRC

* Norm Matloff, *The Art of Machine Learning: Algorithms+Data+R*, NSP,
  coming January 2024

**Other**

* Rob Hyndman and George Athanasopoulos, *Forecasting: Principles and Practice*,
OTexts 

* Ted Kwartler, *Text Mining in Practice with R*

* Norm Matloff, *Probability and Statistics for Data Science: Math + R +
Data*, CRC

* Julia Silge and David Robinson, *Text Mining with R: A Tidy Approach*,
O'Reilly

* Yihui Xie *et al*, *R Markdown: The Definitive Guide*, CRC 

**Web**

I also would recommend various Web tutorials:

* Szilard Palka, 
[CEU Business Analytics program: Use Case Seminar 2 with Szilard Pafka (2019- 05-08)](https://t.co/kbhw44Tbbn) 

* Hadley Wickham, 
[the Tidyverse](https://www.tidyverse.org) 

## <a name="thanks"> 感谢 </a>

作者对Kyle Butts在2022年7月对格式的一些改进表示感谢。

本教程还受益于（按字母顺序排列）Clay Ford、Reese Goding、Ira Sharenow和Aaron Wichman的反馈，以及许多匿名建议。

## <a name="ide"> 安装和使用集成开发环境（IDE） </a>

集成开发环境（IDE）是一种软件工具，它使编辑、保存和运行您的代码以及相关操作（如安装包）成为可能。

真正的“高级用户”倾向于使用Emacs Speaks Statistics (ESS)，这是Emacs编辑器的插件，或者Nvim-r，这是vim编辑器的插件。然而，由于本教程面向的是那些没有或几乎没有编码背景的人，我们将不涉及它们。相反，我们介绍RStudio。以下是一些优缺点：

* RStudio非常受欢迎，特别是在美国和澳大利亚/新西兰。实际上，对于许多用户来说，RStudio *就是* R。

* 在网络上和已经在许多主要城市建立的R用户组中都可以获得很多帮助。具有众多功能、键盘快捷键等。

* 然而，这也有一个缺点，因为如前所述，RStudio的复杂性可能会令人“不知所措”。

考虑到最后一点，我们建议您在一开始不要试图学习RStudio到任何复杂程度。只需学习如何创建、加载、运行和保存R代码文件，即简单的内容，这应该很容易。把高级功能留给以后再说。

### 安装

在Web上有很多关于安装RStudio的教程。[这个](https://techvidvan.com/tutorials/install-r/)对于所有主要平台都很好。

### 启动

如果您的屏幕上有一个RStudio图标，请点击它。否则，在终端窗口中键入'r studio'。

### 基本操作：

同样，除了下面介绍的绝对基础操作外，还有很多其他操作。

注意RStudio屏幕左下部分的窗格。默认情况下，这是控制台窗格，包含常规的R '>'提示符。您可以像在本教程中一样使用它。还要注意，这是您的R输出将出现的地方。

这里的一切都涉及文件，我们在其中存储我们的R代码（*脚本*）。

**创建新的代码文件：** 文件 | 新建文件 | R脚本将创建一个空的窗格，准备填入代码。开始输入吧！

**保存代码文件：** 文件 | 保存将保存窗格的内容。如果是一个新文件，您将被要求给文件命名。确保注意文件将存储在哪个文件夹中，以便稍后知道从哪里读取它。

**运行代码：** 要运行当前窗口中的代码，请选择代码 | 运行区域 | 运行所有。

**退出RStudio：**

文件 | 退出会话...

## 许可

该文档受
[创作共用](http://creativecommons.org/licenses/by-nd/3.0/us/) 许可的保护，
创作共用署名-禁止演绎3.0美国
![alt text](http://i.creativecommons.org/l/by-nd/3.0/us/88x31.png)。我已经
撰写了这个文档以供*使用*，因此读者、教师等非常欢迎和鼓励直接复制它。在所有非美国司法管辖区，版权归N. Matloff所有，但只要显示了这里的作者和许可信息，仍然允许在教学中使用这些材料。我会很高兴知道您是否使用这本书进行教学，这样我就知道材料正在被使用，但这并不是必须的。信息显示。对于这些材料，不提供或暗示任何保修。
